


Timer/Counter/Analyzer
CNT-90, CNT-91

Frequency Calibrator/Analyzer
CNT-91R

Microwave Counter/Analyzer
CNT-90XL


Programmer’s Handbook









































4031 600 90201
August 2010 - Ninth Edition

© 2010 Spectracom Corporation. All rights reserved.
Printed in Sweden.

GENERAL INFORMATION
About this Manual
This manual contains directions for use that apply to the Timer/Counter/Analyzers CNT-90 and CNT-91, the Frequency Calibrator/Analyzer CNT-91R, and the Microwave Counter/Analyzer CNT-90XL. In order to simplify the references, the instruments are further referred to throughout this manual as the '9X', whenever the information applies to all types. Differences are clearly marked.
In Chapter 8, Command Reference, the commands that do not apply to all instruments are marked with the relevant type number.

Warranty
The Warranty Statement is part of the folder Important Information that is included with the shipment.

Declaration of Conformity
The complete text with formal statements concerning product identification, manufacturer and standards used for type testing is available on request.






















This page is intentionally left blank.

Table of Contents




:CALCulate :AVERage :COUNt :
CURRent?	8-13
:CALCulate :AVERage :TYPE	8-14
:CALCulate :DATA?	8-14
:CALCulate :IMMediate	8-15
:CALCulate :LIMit	8-15
:CALCulate :LIMit :CLEar	8-16
:CALCulate :LIMit :CLEar :AUTO	8-16
:CALCulate :LIMit :FAIL?	8-17
:CALCulate :LIMit :FCOunt :LOWer?	8-17
:CALCulate :LIMit :FCOunt?	8-18
:CALCulate :LIMit :FCOunt :UPPer?	8-18
:CALCulate :LIMit :PCOunt?	8-19
:CALCulate :LIMit :LOWer	8-19
:CALCulate :LIMit :LOWer :STATe	8-20
:CALCulate :LIMit :UPPer	8-20
:CALCulate :LIMit :UPPer :STATe	8-21
:CALCulate :MATH	8-21
:CALCulate :MATH :STATe	8-22
:CALCulate :STATe	8-22
:CALCulate :TOTalize :TYPE	8-23
Calibration Subsystem	8-25
:CALibration :INTerpolator :AUTO	8-26
Configure Function	8-27
:CONFigure :<Measuring Function>	8-28
:CONFigure :ARRay :<Measuring
Function>	8-29
:CONFigure :TOTalize [:CONTinuous]	8-30
Display Subsystem	8-31
:DISPlay :ENABle	8-32
Fetch Function	8-33
:FETCh?	8-34
:FETCh :ARRay?	8-35
Format Subsystem	8-37
:FORMat	8-38
:FORMat :BORDer	8-38
:FORMat :SMAX	8-39
:FORMat :TINFormation	8-40
Hard Copy	8-41
:HCOPy :SDUMp :DATA?	8-42
Initiate Subsystem	8-43
:INITiate	8-44
:INITiate :CONTinuous	8-44
Input Subsystems	8-45
:INPut«[1]|2» :ATTenuation	8-46
:INPut«[1]|2» :COUPling	8-46
:INPut«[1]|2» :FILTer	8-47
:INPut«[1]|2» :FILTer :DIGital	8-47
:INPut«[1]|2» :FILTer :DIGital :
FREQuency	8-48
:INPut«[1]|2» :IMPedance	8-48
:INPut«[1]|2» :LEVel	8-49
:INPut«[1]|2» :LEVel :AUTO	8-49
:INPut«[1]|2» :LEVel :RELative	8-50
:INPut«[1]|2» :SLOPe	8-51
Measurement Function	8-53
:MEASure :<Measuring Function>?	8-56
:MEASure :ARRay :
<Measuring Function>?	8-57
:MEASure :MEMory<N>?	8-58
:MEASure :MEMory?	8-58
EXPLANATIONS OF THE MEASURING FUNCTIONS	8-59
:MEASure :FREQuency?	8-60
:MEASure :FREQuency :BURSt?	8-61
:MEASure :FREQuency :POWer [:AC]? . 8-61
:MEASure :FREQuency :PRF?	8-62
:MEASure :FREQuency :RATio?	8-63
:MEASure [:VOLT] :NCYCles?	8-63
:MEASure «:PDUTycycle | :DCYCle»?	8-64
:MEASure :NDUTycycle?	8-64
:MEASure [:VOLT] :MAXimum?	8-65
:MEASure [:VOLT] :MINimum?	8-65
:MEASure [:VOLT] :PTPeak?	8-66
:MEASure [:VOLT] :RATio?	8-66
:MEASure [:VOLT] :PSLEwrate?	8-67
:MEASure [:VOLT] :NSLEwrate?	8-67
:MEASure :PERiod?	8-68
:MEASure :PERiod :AVERage?	8-68
:MEASure :PHASe?	8-69
:MEASure «:RISE :TIME | :RTIM»?	8-69
:MEASure «:FALL :TIME | :FTIM»?	8-70
:MEASure :TINTerval?	8-70
:MEASure :PWIDth?	8-71
:MEASure :NWIDth?	8-71
:MEASure :ARRay :STSTamp?	8-72
:MEASure :ARRay :TSTAmp?	8-73

:MEASure: ARRay: FREQuency:
BTBack?	8-74
:MEASure: ARRay: PERiod: BTBack?	8-74
:MEASure: ARRay: TIError?	8-75
Memory Subsystem	8-77
:MEMory :DATA :RECord :COUNt?	8-78
:MEMory :DATA :RECord :DELete	8-78
:MEMory :DATA :RECord :FETCh?	8-79
:MEMory :DATA :RECord :FETCh :
ARRay?	8-79
:MEMory :DATA :RECord :FETCh :
STARt	8-80
:MEMory :DATA :RECord :NAME?	8-80
:MEMory :DATA :RECord :SAVE	8-81
:MEMory :DATA :RECord :SETTings?	8-81
:MEMory :FREE :MACRo?	8-82
:MEMory :DELete :MACRo	8-82
:MEMory :NSTates?	8-83
Output Subsystem	8-85
:OUTPut :POLarity	8-86
:OUTPut :TYPE	8-86
Read Function	8-87
:READ?	8-88
:READ :ARRay?	8-89
Sense Command Subsystem	8-91
:ACQuisition :APERture	8-92
:ACQuisition :HOFF	8-92
:ACQuisition :HOFF :TIME	8-93
:AUTO	8-93
:FREQuency :BURSt :PREScaler
[:STATe]	8-94
:FREQuency :BURSt :APERture	8-94
:FREQuency :BURSt :SYNC :PERiod	8-95
:FREQuency :BURSt :STARt :DELay	8-95
:FREQuency :POWer :UNIT	8-96
:FREQuency :RANGe :LOWer	8-96
:FUNCtion	8-97
:FREQuency :REGRession	8-97
:HF :ACQuisition [:STATe]	8-99
:HF :FREQuency :CENTer	8-99
:ROSCillator :SOURce	8-100
:TIError :FREQuency :AUTO	8-100
:TINTerval :AUTO	8-101
:TIError :FREQuency	8-101
:TOTalize :GATE	8-102
Source Subsystem	8-103
:SOURce :PULSe :PERiod	8-104
:SOURce :PULSe :WIDTh	8-104
Status Subsystem	8-105
:STATus :DREGister0?	8-106
:STATus :DREGister0 :ENABle	8-106
:STATus :OPERation :CONDition?	8-107
:STATus :OPERation :ENABle	8-108
:STATus: OPERation?	8-109
:STATus :PRESet	8-109
:STATus :QUEStionable :CONDition?.	8-110
:STATus :QUEStionable :ENABle	8-111
:STATus :QUEStionable?	8-111
System Subsystem	8-113
:SYSTem :COMMunicate :GPIB :
ADDRess	8-114
:SYSTem :ERRor?	8-114
:SYSTem :LANGuage	8-115
:SYSTem: INSTRument: TBASe: LOCK? . 8-115
:SYSTem :SET	8-116
:SYSTem :PRESet	8-116
:SYSTem :TEMPerature?	8-117
:SYSTem :TALKonly	8-117
:SYSTem :TOUT :AUTO	8-118
:SYSTem :TOUT	8-118
:SYSTem :UNPRotect	8-119
:SYSTem :TOUT :TIME	8-119
Test Subsystem	8-121
:TEST :SELect	8-122
Trigger Subsystem	8-123
:TRIGger :COUNt	8-124
:TRIGger :SOURce	8-124
:TRIGger: TIMer	8-125
Common Commands	8-127
*CLS	8-128
*DDT	8-128
*DMC	8-129
*EMC	8-130
*ESE	8-131
ESR?	8-132
*GMC?	8-132
*IDN?	8-133

*LMC? .	8-133
*LRN?	8-134
*OPC	8-134
*OPC?	8-135
*OPT?	8-135
*PMC	8-136
*PSC	8-136
*PUD	8-137
*RCL	8-137
RMC	8-138
*RST	8-138
*SAV	8-139
*SRE	8-140
*STB?	8-141
*TRG	8-141
*TST?	8-142
*WAI	8-142
Index





Chapter 1

Getting Started


Finding Your Way Through This Manual


You should use this Programmer's Handbook together with the User's Manual. That manual contains speci- fications for the counter and explana- tions of the possibilities and limitations of the different measuring functions.
Sections
The chapters in this manual are di- vided into three sections aimed at dif- ferent levels of reader knowledge.
The ‘General’ Section, which can be disregarded by the users who know the IEEE-488 and SCPI standards:
Chapter 2, Default Settings, sum- marizes the instrument settings af- ter sending the *RST command.
Chapter 3, Introduction to SCPI, explains syntax data formats, sta- tus reporting, etc.
The Practical Section of this manual contains:
Chapter 4, Programming Exam- ples, with typical programs for a number of applications. These programs are written in C and are also available as text files on the included Manual CD.
The “Programmer’s Reference” Sec- tion of this manual contains:
Chapter 5, Instrument Model, ex- plains how the instrument looks from the bus. This instrument is not quite the same as the one used from the front panel.
Chapter 6, Using the Subsystems, explains more about each subsys- tem.
Chapter 7, Error Messages, con- tains a list of all error messages that can be generated during bus control.
Chapter 8, Command Reference, gives complete information on all commands. The subsystems and commands are sorted alphabeti- cally.
Index
You can also use the index to get an overview of the commands. The in- dex is also useful when looking for additional information on the com- mand you are currently working with.




Manual Conventions
Syntax Specification Form
This manual uses the EBNF (Extended Backus-Naur Form) notation for describ- ing syntax. This notation uses the follow- ing types of symbols:
Printable Characters:
Printable characters such as Command headers, etc., are printed just as they are,
e.g. period means that you should type the word PERIOD.
The following printable characters have a special meaning and will only be used in that meaning: # ‘ “ () : ; *
Read Chapter 3’ Introduction to SCPI’ for more information.
Non-printable Characters:
Two non-printable characters are used:
- indicates the space character (ASCII code 32).
 _ indicates the new line character (ASCII code 10).
Specified Expressions: < >
Symbols and expressions that are further specified elsewhere in this manual are placed between the <> signs.
For example <Dec. data.>. The following explanation is found on the same page: “Where <Dec. data> is a four-digit num- ber between 0.1 and 8*10-9.
Alternative Expressions Giving Different Result:
Alternative expressions giving different results are separated by |. For example, On|Off means that the function may be switched on or off.
Grouping: « »
Example: FORMat-«ASCII|REAL» specifies the command header FORMat followed by a space character and either ASCII or REAL.
Optionality: [ ]
An expression placed within [ ] is op- tional.
Example: [:VOLT]:FREQuency
means that the command FREQuency may or may not be preceded by :VOLT.
Repetition: { }
An expression placed within { } can be repeated zero or more times.
Equality: =
Equality is specified with = Example: <Separator>= ,

Mnemonic Conventions
Truncation Rules
All commands can be truncated to shortforms. The truncation rules are as follows:
The shortform is the first four characters of the command.
If the fourth character in the command is a vowel, then the shortform is the first three characters of the command. This rule is not




used if the command is only four charac- ters.
If the last character in the command is a digit, then this digit is appended to the shortform.
Examples:


The shortform is always printed in CAPI- TALS in this manual: :MEASure, :NEG- ative, :DREGister0, :EXTernal4 etc.
Example Language
Small examples are given at various places in the text. These examples are not in BASIC or C, nor are they written for any specific controller. They only contain the characters you should send to the counter and the responses that you should read with the controller.
Example:
SEND MEAS:FREQ?
This means that you should program the controller so that it addresses the counter and outputs this string on the GPIB.
READ 1.234567890E6
This means that you should program the controller so that it can receive this data from the GPIB, then address the counter and read the data.
Setting Up the Instrument
Setting the GPIB Address
The address of the counter is set to 10 when it is delivered. Press USER OPT → Interface to see the active address above the soft key labeled GPIB address.
If you want to use another bus address, you can press GPIB address to enter a value menu where you can set the address between 0 and 30 by means of the nu- meric keys.
The address can also be set via a GPIB command. The set address is stored in nonvolatile memory and remains until you change it.

Power-On
When turned on, the counter starts with the setting it had when turned off.
Standby
When the counter is in REMOTE mode, you cannot switch it off. You must first enable Local control by pressing the Can- cel ("C") key.

Testing the Bus
To test that the instrument is operational via the bus, use *IDN? to identify the in- strument and *OPT? to identify which options are installed. (See ‘System Sub- system’ , *IDN? and *OPT?)




Interface Functions
What can I do with the Bus?
All the capabilities of the interface for the '9X' are explained below.
Summary


SH1 and AH1
These simply mean that the counter can exchange data with other instruments or a controller using the bus handshake lines: DAV, NRFD, NADC.
Control Function, C0
The counter does not function as a con- troller.
Talker Function, T6
The counter can send responses and the results of its measurements to other de- vices or to the controller. T6 means that it has the following functions:
Basic talker.
No talker only.
It can send out a status byte as response to a serial poll from the controller.
Automatic un-addressing as a talker when it is addressed as a listener.
Listener Function, L4
The counter can receive programming in- structions from the controller. L4 means that it has the following functions:
Basic listener.
No listen only.
Automatic un-addressing as listener when addressed as a talker.
Service Request, SR1
The counter can call for attention from the controller, e.g., when a measurement is completed and a result is available.
Remote/Local, RL1
You can control the counter manually (locally) from the front panel or remotely from the controller. The LLO, lo- cal-lock-out function, can disable the LO- CAL button on the front panel.
Parallel Poll, PP0
The counter does not have any parallel poll facility.
Device Clear, DC1
The controller can reset the counter via interface message DCL (Device clear) or SDC (Selective Device Clear).




Device Trigger, DT1
You can start a new measurement from the controller via interface message GET (Group Execute Trigger).
Bus Drivers, E2
The GPIB interface has tri-state bus driv- ers.


Using the USB Interface
The counter is equipped with a USB full speed interface, which supports the same SCPI command set as the GPIB interface.
The USB interface is a full speed inter- face (12 Mbit/s), supporting the industry standard USBTMC (Universal Serial Bus Test and Measurement Class) revision 1.0, with the subclass USB488, revision
1.0. The full specification for this proto- col can be found at www.usb.org.
A valid driver for this protocol must be installed to be able to communicate over USB. We recommend NI-VISA version
3.2 or above, which is available for sev- eral operating systems, from National In- struments (www.ni.com). The Windows version is supplied on the CD.
In order to test the communication and send single commands, the National In- struments utility supplied with the NI-VISA drivers can be used to open a “VISA session” to send and receive data from the instrument, and also set control signals such as Remote or Local.
Third party application programs, such as LabView, normally support USB com-
munication directly, for example through the Instrument I/O Assistant.
Custom specific programs using USB communication can be written in C/C++, supported by libraries and lib-files sup- plied with the NI-VISA driver (default location C:\VXIPNP\WinNT\). A sample program is found on page 4-11.
Instruments connected to the USB bus are identified with:
Vendor ID: 0x14EB for Pendulum Instru- ments.
Model ID: 0x0090 for the '90' and serial number of the instrument.
This data is combined to form a unique identifier string such as:
USB\VID_14EB&PID_0090\991234 or

“USB0::0x14EB::0x0090::991234::INSTR”
When connecting to the instrument, any part of this string may be used to identify the instrument, for example any instru- ment from this vendor, any instrument of a certain type or a specific instrument serial number.




Chapter 2

Default Settings


Default settings (after *RST)





Chapter 3

Introduction to SCPI



What is SCPI?
SCPI (Standard Commands for Programmable Instruments) is a standard- ized set of commands used to remotely control programmable test and measure- ment instruments. The instrument firm- ware contains the SCPI. It defines the syntax and semantics that the controller must use to communicate with the instru- ment.
This chapter is an overview of SCPI and shows how SCPI is used in Pendulum Frequency Counters and Timer/Counters.
SCPI is based on IEEE-488.2 to which it owes much of its structure and syntax. SCPI can, however, be used with any of the standard interfaces, such as GPIB (=IEC625/IEEE-488), VXI and RS-232.

Reason for SCPI
For each instrument function, SCPI de- fines a specific command set. The advan- tage of SCPI is that programming an instrument is only function dependent and no longer instrument dependent. Sev- eral different types of instruments, for ex- ample an oscilloscope, a counter and a multimeter, can carry out the same func- tion, such as frequency measurement. If these instruments are SCPI compatible, you can use the same commands to mea- sure the frequency on all three instru- ments, although there may be differences in accuracy, resolution, speed, etc.
Compatibility
SCPI provides two types of compatibil- ity: Vertical and horizontal.

AC
Figure 3-1	Vertical
This means that all instruments of the same type have identical controls. For example, oscilloscopes will have the same controls for timebase, triggers and voltage settings.



10.1234567890E3

Figure 3-2	Horizontal
This means that instruments of different types that perform the same functions have the same commands. For exam- ple, a DMM, an oscilloscope, and a counter can all measure frequency with the same commands.




Management and Maintenance of Programs
SCPI simplifies maintenance and man- agement of the programs. Today changes and additions in a good working program are hardly possible because of the great diversity in program messages and instru- ments. Programs are difficult to under- stand for anyone other than the original programmer. After some time even the programmer may be unable to understand them.
A programmer with SCPI experience, however, will understand the meaning and reasons of a SCPI program, because of his knowledge of the standard. Changes, extensions, and additions are much easier to make in an existing appli- cation program. SCPI is a step towards portability of instrument programming software and, as a consequence, it allows the exchange of instruments.



Figure 3-3	Overview of the firmware in a SCPI instrument.




How does SCPI Work in the Instrument?
The functions inside an instrument that control the operation provide SCPI com- patibility. Figure 3-3 shows a simplified logical model of the message flow inside a SCPI instrument.
When the controller sends a message to a SCPI instrument, roughly the following happens:
The GPIB controller addresses the instru- ment as listener.
The GPIB interface function places the message in the Input Buffer.
The Parser fetches the message from the Input Buffer, parses (decodes) the message, and checks for the correct syntax. The in- strument reports incorrect syntax by send- ing command errors via the status system to the controller. Moreover, the parser will detect if the controller requires a response. This is the case when the input message is a query (command with a “?” appended).
The Parser will transfer the executable messages to the Execution Control block in token form (internal codes). The Exe- cution Control block will gather the in- formation required for a device action and will initiate the requested task at the appropriate time. The instrument reports execution errors via the status system over the GPIB and places them in the Er- ror Queue.
When the controller addresses the instru- ment as talker, the instrument takes data from the Output Queue and sends it over the GPIB to the controller.
Message Exchange Control protocol
Another important function is the Mes- sage Exchange Control, defined by IEEE 488.2. The Message Exchange Control protocol specifies the interactions between the several functional elements that exist between the GPIB functions and the device-specific functions, see Figure 3-3 .
The Message Exchange Control protocol specifies how the instrument and control- ler should exchange messages. For exam- ple, it specifies exactly how an instrument shall handle program and re- sponse messages that it receives from and returns to a controller.
This protocol introduces the idea of com- mands and queries; queries are program messages that require the device to send a response. When the controller does not read this response, the device will gener- ate a Query Error. On the other hand, commands will not cause the device to generate a response. When the controller tries to read a response anyway, the de- vice then generates a Query Error.
The Message Exchange Control protocol also deals with the order of execution of program messages. It defines how to re- spond if Command Errors, Query Errors, Execution Errors, and Device-Specific er- rors occur. The protocol demands that the instrument report any violation of the IEEE-488.2 rules to the controller, even when it is the controller that violates these rules.
The IEEE 488.2 standard defines a set of operational states and actions to imple- ment the message exchange protocol. These are shown in the following table:






Protocol Requirements
In addition to the above functional ele- ments, which process the data, the mes- sage exchange protocol has the following characteristics:
The controller must end a program mes- sage containing a query with a message terminator before reading the response from the device (address the device as talker). If the controller breaks this rule, the device will report a query error (unterminated action).
The controller must read the response to a query in a previously (terminated) program message before sending a new program
message. When the controller violates this rule, the device will report a query error (interrupted action).
The instrument sends only one response message for each query message. If the query message resulted in more than one answer, all answers will be sent in one re- sponse message.
Order of Execution
Deferred Commands
Execution control collects commands un- til the end of the message, or until it finds a query or other special command that forces execution. It then checks that the setting resulting from the commands is a valid one: No range limits are exceeded, no coupled parameters are in conflict, etc. If this is the case, the commands are exe- cuted in the sequence they have been re- ceived; otherwise, an execution error is generated, and the commands are dis- carded.
This deferred execution guarantees the following:
All valid commands received before a query are executed before the query is exe- cuted.
All queries are executed in the order they are received.
The order of execution of commands is never reversed.
Sequential and Overlapped Commands
There are two classes of commands: se- quential and overlapped commands. All commands in the counter are sequential, that is one command finishes before the next command executes.



Remote Local Protocol
Definitions
Remote Operation
When an instrument operates in remote, all local controls, except the local key, are disabled.
Local Operation
An instrument operates in local when it is not in remote mode as defined above.
Local Lockout
In addition to the remote state, an instru- ment can be set to remote with ‘local lockout’. This disables the return-to-local button. In theory, the state local with lo- cal lockout is also possible; then, all local controls except the return-to-local key are active.
The Counter in Remote Operation
When the Counter is in remote operation, it disables all its local controls except the LOCAL key.
The Counter in Local Operation
When the Counter is in local operation the instrument is fully programmable both from the front panel and from the bus. If a bus message arrives while a change is being entered from the front panel, the front panel entry is interrupted and the bus message is executed.
We recommend you to use Remote mode when using counters from the bus. If not, the counter measures continously and the initiation command :INIT will have no effect.


Program and Response Messages


The communication between the system controller and the SCPI instruments con- nected to the GPIB takes place through Program and Response Messages. A Pro- gram Message is a sequence of one or more commands sent from the controller to an instrument. Conversely, a Response Message is the data from the instrument to the controller.
One or more program message units (commands) may be sent within a simple program message, see Fig. 3-6.

Fig 3-6	Syntax of a terminated
Program Message.






Figure 3-4	Program and response
messages.
The GPIB controller instructs the device through program messages. The device will only send responses when explicitly requested to do so; that is, when the con- troller sends a query. Queries are recog- nized by the question mark at the end of the header, for example: *IDN? (requests the instrument to send identity data).

Syntax and Style
Syntax of Program Messages
A command or query is called a program message unit. A program message unit consists of a header followed by one or more parameters, as shown in .

Figure 3-5	Syntax of a Program
Message Unit.
The J is the PMT (program message terminator) and it must be one of the fol- lowing codes:


NL is the same as the ASCII LF (<line feed> = ASCII 10decimal ). The END message is sent via the EOI-line of the GPIB.
The ^ character stands for ‘at the same time as’.
The possibility to use NL as the sole PMT was added to instru- ment FW V1.25 in compatible mode only, and to V1.26 in both compatible and native mode. FW loader V3.03 or later must be used as from these versions.




Most controller programming languages send these terminators automatically, but allow changing it. So make sure the ter- minator is as above.
Example of a terminated program mes- sage:
:INP:IMP  1E6;:ACQ:APER  0.1NL^END
root level keyword, representing the highest hierarchical level in the command tree.
The keywords following represent subnodes under the root node. See ‘COMMAND TREE’ on page 3-10 for more details of this subject.
Forgiving Listening

program message unit
terminator
The syntax specification of a command is

program message unit
This program message consists of two message units. The unit separator (semi- colon) separates message units.
Basically there are two types of com- mands:
Common Commands
The common command header starts with the asterisk character (*), for example
*RST.
SCPI Commands
SCPI command headers may consist of several keywords (mnemonics), separated by the colon character (:).
as follows:
ACQuisition:APERture-<numeric value>
Where: ACQ and APER specify the shortform, and ACQuisition and APER- ture specify the longform. However, ACQU or APERT are not allowed and cause a command error.
In program messages either the long or the shortform may be used in upper or lower case letters. You may even mix up- per and lower case. There is no semantic difference between upper and lower case in program messages. This instrument be- havior is called forgiving listening.
For example, an application program may send the following characters over the

Root
Endnode
bus:
SEND iNp:ImP-1E6
The example shows the shortform used in a mix of upper and lower case
SEND Input:Imp-1E6

Figure 3-7  The SCPI command tree.

Each keyword in a SCPI command header represents a node in the SCPI command tree. The leftmost keyword (INPut in the previous example) is the
The example shows a mix of longform and shortform and a mix of upper and lower case.




Notation Habit in Command Syntax
To clarify the difference between the forms, the shortform in a syntax specifi- cation is shown in upper case letters and the remaining part of the longform in lower case letters.
Notice however, that this does not specify the use of upper and lower case charac- ters in the message that you actually sent. Upper and lower case letters, as used in syntax specifications, are only a notation convention to ease the distinction be- tween longform and shortform.
Syntax of Response Messages
The response of a SCPI instrument to a query (response message unit) consists of one or more parameters (data elements) as the following syntax diagram shows. There is no header returned.

Figure 3-8   Syntax of a Response
Message Unit.
If there are multiple queries in a program message, the instrument groups the multi- ple response message units together in one response message according to the following syntax:


Fig 3-9	Syntax of a Terminated
Response Message.

The response message terminator (rmt) is always NL^END, where:
NL^END is <new line> code (equal to
<line feed> code = ASCII 10 decimal) sent concurrently with the END message. The END message is sent by asserting the EOI line of the GPIB bus.
Responses:
A SCPI instrument always sends its re- sponse data in shortform and in capitals.
Example:
You program an instrument with the fol- lowing command:
SEND :ROSCillator:SOURce-EX- Ternal
Then you send the following query to the instrument:
SEND :ROSCillator:SOURce?
The instrument will return:
READ EXT
response in shortform and in capitals.




Command Tree
Command Trees like the one below are used to document the SCPI command set in this manual. The keyword (mnemonic) on the root level of the command tree is the name of the subsystem. The follow- ing example illustrates the Command
Tree of the INPut1 subsystem.

<HEADER>	Parameters
:lNPut[1]
Example:
SEND ARM:STARt:SLOPe-NEG
Where: ARM is the root node and SLOPe is the leaf node.
Each colon in the command header moves the current path down one level from the root in the command tree. Once you reach the leaf node level in the tree, you can add several leaf nodes without having to repeat the path from the root level.

:lMPedance
:FlLTer
[:LPASs]
-<Numericvalue>|MAX|MlN
Just follow the rules below:
– Always give the full header path, from the root, for the first command in a new pro-

 [:STATe] -<Boolean>
Figure 3-10	Example of an INPut
subsystem command tree.

The keywords placed in square brackets are optional nodes. This means that you may omit them from the program message.
Example:
SEND INPUT1:FILTER:LPASS
:STATE-ON
is the same as
SEND INPUT:FILTER-ON

Moving down the Command Tree
The command tree shows the paths you should use for the command syntax. A single command header begins from the root level downward to the ‘leaf nodes’ of the command tree. (Leaf nodes are the last keywords in the command header, before the parameters.)
gram message.
For the following commands within the same program message, omit the header path and send only the leaf node (without colon).
You can only do this if the header path of the new leaf-node is the same as that of the previous one. If not, the full header path must be given starting witha colon.
Command header = Header path + leaf node
Once you send the PMT (program message terminator), the first command in a new program message must start from the root.
Example:
SEND ARM:STARt:SLOPe-NEG; DELay-0.1




This is the command where:
ARM:STARt is the header path and
:SLOPe is the first leaf node and DE- Lay is the second leaf node because DELay is also a leaf node under the header path ARM:STARt.
There is no colon before DELay!


Parameters
Numeric Data
Decimal data are printed as numerical values throughout this manual. Numeric values may contain both a decimal point and an exponent (base 10).
These numerals are often represented as NRf (NR = NumeRic, f = flexible) format.
Keywords
In addition to entering decimal data as numeric values, several keywords can ex- ist as special forms of numeric data, such as MINimum, MAXimum, DEFault, STEP, UP, DOWN, NAN (Not A Num-
ber), INFinity, NINF (Negative INFi- nity). The Command Reference chapters explicitly specify which keywords are al- lowed by a particular command. Valid keywords for the counter are MAXimum and MINimum.
MINimum
This keyword sets a parameter to its min- imum value.
MAXimum
This keyword sets a parameter to its max- imum value.
The instrument always allows MINimum and MAXimum as a data element in com- mands, where the parameter is a numeric value. MIN and MAX values of a param- eter can always be queried.
Example:
SEND INP:LEV?-MAX
This query returns the maximum range value.
Suffixes
You can use suffixes to express a unit or multiplier that is associated with the deci- mal numeric data. Valid suffixes are s (seconds), ms (milliseconds), mohm (megaohm), kHz (kilohertz), mV (milli- volt).
Example:
SEND :SENS:ACQ:APER-100ms
Where: ms is the suffix for the numeric value 100.
Notice that you may also send ms as MS or mS. MS does still mean milliseconds, not Mega Siemens!
Response messages do not have suffixes. The returned value is always sent using standard units such as V, S, Hz, unless you explicitly specify a default unit by a FORMat command.

Boolean Data
A Boolean parameter specifies a single binary condition which is either true or false.
Boolean parameters can be one of the fol- lowing:
ON or 1 means condition true.
OFF or 0 means condition false.




Example
SEND :SYST:TOUT-ON or
:SYST:TOUT-1
This switches timeout monitoring on.
A query, for instance :SYSTem:TOUT?, will return 1 or 0; never ON or OFF.
Expression Data
You must enclose expression program data in parentheses (). Three possibilities of expression data are as follows:
<numeric expression data>
<parameter list>
<channel list>
An example of <numeric expression data> is: (X – 10.7E6) This subtracts a 10.7 MHz intermediate frequency from the mea- sured result.
An example of <parameter list> is: (5,0.02) This is a list of two parameters; the first one is 5 and the second one 0.02.
An example of <channel list> is: (@3),(@1) This specifies channel 3 as the main channel and channel 1 as the second
channel.
Other Data Types
Other data types that can be used for pa- rameters are the following:
String data: Always enclosed between sin- gle or double quotes, for example
“This is a string” or ‘This is a string.’
Character data: For this data type, the same rules apply as for the command header mnemonics. For example: POSitive, NEG- ative, EITHer.
Non-decimal data: For instance, #H3A for hexa decimal data.
Block data: Used to transfer any 8-bit coded data. This data starts with a pream- ble that contains information about the length of the parameter.

Example:
#218INP:IMP-50;SENS-10

Summary





Macros
A macro is a single command, that repre- sents one or several other commands, de- pending on your definition. You can define 25 macros of 40 characters in the counter. One macro can address other macros, but you cannot call a macro from within itself (recursion). You can use variable parameters that modify the macro.
Use macros to do the following:
Provide a shorthand for complex com- mands.
Cut down on bus traffic.

Macro Names
You can use both commands and queries as macro labels. The label cannot be the same as common commands or queries. If a macro label is the same as a counter command, the counter will execute the macro  when  macros  are  enabled
(*EMC-1), and it will execute the counter command when macros are dis- abled (*EMC-0).
Data Types within Macros
The commands to be performed by the macro can be sent both as block and string data.
String data is the easiest to use since you don’t have to count the number of charac- ters in the macro. However, there are some things you must keep in mind:
Both double quote (“) and single quote (‘) can be used to identify the string data. If you use a controller language that uses double quotation marks to define strings
within the language (like BASIC) we rec- ommend that you use block data instead, and use single quotes as string identifiers within the macro.
When using string data for the commands in a macro, remember to use a different type of string data identifiers for strings within the macro. If the macro should for instance set the input slope to positive and select the period function, you must type:
“:Inp:slope-pos;:Func-’PER-1’”
or
‘:Inp:slope-pos;:Func-"PER-1"’

Define Macro Command
*DMC assigns a sequence of commands to a macro label. Later when you use the macro label as a command, the counter will execute the sequence of commands.
Use the following syntax:
*DMC <macro-label>, <commands>
Simple Macros
Example:
SEND *DMC-‘ECL_RiseTime’, #268:INP:LEV:AUTO-ON;REL
-20;:INP:IMP-50;COUP-DC;
:INP2:LEV:AUTO-ON;REL-80
This example defines a macro “ECL_RiseTime”, which sets the imped- ance to 50 , the coupling to DC, and the relative trigger levels to 20 % and 80 %, in order to make the necessary prepara- tions for measuring rise time of ECL logic signals on Input A.




Macros with Arguments
You can pass arguments (variable param- eters) with the macro. Insert a dollar sign ($) followed by a single digit in the range 1 to 9 where you want to insert the pa- rameter. See the example below.
When a macro with defined arguments is used, the first argument sent will replace any occurrence of $1 in the definition; the second argument will replace $2, etc.
Example:
SEND *DMC-‘AUTO’,
‘:INP:LEV:AUTO-$1;
:INP:IMP-$2’
This example defines a macro AUTO, which takes two arguments, i.e., auto
«ON|OFF|ONCE» ($1) and impedance
«50|1E6» ($2) .
SEND AUTO-OFF,50
Switches off auto trigger level and sets the input impedance to 50 .

Deleting Macros
Use the *PMC (purge macro) command to delete all macros defined with the
*DMC command. This removes all macro labels and sequences from the memory. To delete only one macro in the memory, use the :MEMory:DE- Lete:MACRo command.
You cannot overwrite a macro; you must delete it before you can use the same name for a new macro.
Enabling and Disabling Macros
*EMC Enable Macro Command
When you want to execute a counter command or query with the same name as a defined macro, you need to disable macro execution. Disabling macros does not delete stored macros; it just hides them from execution.
Disabling: *EMC-0 disables all macros. Enabling: *EMC-1
*EMC? Enable Macro Query
Use this query to determine if macros are enabled.
Response:
1  macros are enabled
0  macros are disabled

How to Execute a Macro
Macros are disabled after *RST, so to be sure,  start  by  enabling  macros  with
*EMC 1. Now macros can be executed by using the macro labels as commands.
Example:
SEND *DMC-‘LIMITMON’,’
:CALC:STAT-ON;
:CALC:LIM:STAT-ON;
:CALC:LIM:LOW:DATA
$1;STAT-ON;
:CALC:LIM:UPP:DATA
$2;STAT-ON’
SEND *EMC-1
Now sending the command
SEND LIMITMON-1E6,1.1E6
will switch on the limit monitoring to alarm between the limits 1 MHz and
MHz.



Retrieve a Macro
*GMC? Get Macro Contents Query
This query gives a response containing the definition of the macro you specified when sending the query.
Example using the above defined macro:
SEND *GMC?-‘LIMITMON’
READ #292:CALC:STAT
ON;:CALC:LIM:STAT ON;
:CALC:LIM:LOW:DATA
$1;STAT-ON;
:CALC:LIM:UPP:DATA
$2;STAT-ON’
*LMC? Learn Macro Query
This query gives a response containing the labels of all the macros stored in the Timer/Counter.
Example:
SEND *LMC?
READ“MYINPSETTING”,"LIMITMON "
Now there are two macros in memory, and they have the following labels: “MYINPSETTING” and “LIMITMON”.




Status Reporting System
Introduction
Status reporting is a method to let the controller know what the counter is do- ing. You can ask the counter what status it is in whenever you want to know.
You can select some conditions in the counter that should be reported in the Sta- tus Byte Register. You can also select if some bits in the Status Byte should gen- erate a Service Request (SRQ).
(An SRQ is the instrument’s way to call the controller for help.)
Read more about the Status Subsystem in Chapter 6.





Figure 3-11	Model '9X' status register structure.




Error Reporting
The counter will place a detected error in its Error Queue. This queue is a FIFO (First-In First-Out) buffer. When you read the queue, the first error will come out first, the last error last.
If the queue overflows, an overflow mes- sage is placed last in the queue, and fur- ther errors are thrown away until there is room in the queue again.
Detecting Errors in the Queue
Bit 2 in the Status Byte Register shows if the instrument has detected errors. It is also possible to enable this bit for Service Request on the GPIB. This can then inter- rupt the GPIB controller program when an error occurs.
Read the Error/Event Queue
This is done with the :SYSTem:ERRor?
query.
Example:
SEND :SYSTem:ERRor?
READ –100,-“Command-Error”
The query returns the error number fol- lowed by the error description.
Further description of all error numbers can be found in the Er- ror Messages chapter
If more than one error occurred, the query will return the error that occurred first. When you read an error you will also remove it from the queue. You can read the next error by repeating the query. When you have read all errors the queue is empty, and the :SYSTem:ER- Ror? query will return:
0, “No error”
When errors occur and you do not read these errors, the Error Queue may over- flow. Then the instrument will overwrite the last error in the queue with the fol- lowing:
–350, “Queue overflow”
If more errors occur, they will be dis- carded.
Standardized Error Numbers
The instrument reports four classes of standardized errors in the Standard Event Status and in the Error/Event Queue as shown in the following table:


Command Error
This error shows that the instrument de- tected a syntax error.



Execution Error
This error shows that the instrument has received a valid program message which it cannot execute because of some device specific conditions.
Device-specific Error
This error shows that the instrument could not properly complete some device specific operations.
Query Error
This error will occur when the Message Exchange Protocol is violated, for exam- ple, when you send a query to the instru- ment and then send a new command without first reading the response data from the previous query. Also, trying to read data from the instrument without first sending a query to the instrument will cause this error.




Initialization and Resetting
Reset Strategy
There are three levels of initialization:
Bus initialization
Message exchange initialization
Device initialization
Bus Initialization
This is the first level of initialization. The controller program should start with this, which initializes the IEEE-interfaces of all connected instruments. It puts the complete system into remote enable (REN-line active) and the controller sends the interface clear (IFC) command. The command or the command sequence for this initialization is controller and lan- guage dependent. Refer to the user man- ual of the system controller in use.
Message Exchange Initialization
Device clear is the second level of initial- ization. It initializes the bus message ex- change, but does not affect the device functions.
Device clear can be signaled either with DCL to all instruments or SDC (Selective device-clear) only to the addressed instru- ments. The instrument action on receiv- ing DCL and SDC is identical, they will do the following:
Clear the input buffer.
Clear the output queue.
Reset the parser.
Clear any pending commands.
The device-clear commands will not do the following:
Change the instrument settings or stored data in the instrument.
Interrupt or affect any device operation in progress.
Change the status byte register other than clearing the MAV bit as a result of clearing the output queue.
Many older IEEE-instruments, that are not IEEE-488.2 compati- ble returned to the power-on de- fault settings when receiving a device-clear command.
IEEE-488.2 does not allow this.
When to use a Device-clear Command
The command is useful to escape from erroneous conditions without having to alter the current settings of the instru- ment. The instrument will then discard pending commands and will clear re- sponses from the output queue. For ex- ample; suppose you are using the Counter in an automated test equipment system where the controller program returns to its main loop on any error condition in the system or the tested unit. To ensure that no unread query response remains in the output queue and that no unparsed message is in the input buffer, it is wise to use device-clear. (Such remaining re- sponses and commands could influence later commands and queries.)
Device Initialization
The third level of initialization is on the device level. This means that it concerns only the addressed instruments.



The *RST Command
Use this command to reset a device. It initializes the device-specific functions in the Counter.
The following happens when you use the
*RST command:
You set the Counter-specific functions to a known default state. The *RST condition for each command is given in the com- mand reference chapters.
You disable macros.
You set the counter in an idle state (outputs are disabled), so that it can start new oper- ations.
The *CLS Command
Use this command to clear the status data structures. See ‘Status Reporting system’ in this chapter.
The following happens when you use the
*CLS command:
The instrument clears all event registers summarized in the status byte register.
It empties all queues, which are summa- rized in the status byte register, except the output queue, which is summarized in the MAV bit.




Chapter 4


Programming Examples


Introduction
The program examples in this chapter are written in standard 'C' extended with a dedicated library for the National AT-GPIB/TNT controller board.
The programs can be run on PCs using Windows NT and later operating systems.
Even if you use other platforms for your applications, you can benefit from study- ing the examples. They give you a good insight into programming the instrument efficiently.
To be able to run these programs without modification, the address of your counter must be set to 10.


Example 1: Individual Measurements Example 2: Block Measurements Example 3: Fast Measurements Example 4: USB Communication Example 5: Continuous Measurements
For your convenience the examples can also be found on the included manual CD. You are at liberty to copy them for educational purposes.


Individual Mesurements (Ex. #1)
Sample program to perform individual measurements on the '9X'. Written for National AT-GPIB/TNT for Windows NT and later.
/*
**
Sample program to perform individual measurements on the '9X'. Written for National AT-GPIB/TNT for Windows NT and later.
**
*/

#include <windows.h> #include <stdio.h> #include <time.h> #include “decl-32.h”

void ibwrite(int counter, const char *string); void sleep (long mswait);
void main() {
int address = 10;
int i, counter; /* file descriptor for counter */ char reading[50];
char	buf[100];

printf (“Connecting to the '9X' on address %d using National Instruments GPIB card.\n”, address);
if ((counter = ibdev(0, address, 0, T10s, 1, 0)) < 0) { printf(“Could not connect to counter”);
exit(1);
}
ibclr(counter);

do {
ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“Errors before start: %s\n”, buf);
} while (atoi(buf)!=0);

ibwrite(counter, “*idn?”); ibrd(counter, buf, 100L); buf[ibcnt]=0;
printf(“Counter identification string: %s\n”, buf); printf(“Setup\n”);
// Reset counter to known state ibwrite(counter, “*rst;*cls”);




// Setup for pulse width measurement ibwrite(counter, “CONF:PWID (@1)”);

// Some settings...
ibwrite(counter, “AVER:STAT OFF;:ACQ:APER MIN”); ibwrite(counter, “INP:LEV:AUTO OFF; :INP:LEV 0"); ibwrite(counter, ”FORMAT:TINF ON;:FORMAT ASCII");
// Check that setup was OK, all commands correctly spelled etc
ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“Setup error: %s\n”, buf);

// Measure 20 samples for (i=0; i<20; i++) {
ibwrite(counter, “READ?”);
ibrd(counter, reading, 49L); reading[ibcnt]=0; printf(“Result %d:%s”, i, reading);

}
do {





}


ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“End error: %s\n”, buf);
} while (atoi(buf)!=0); ibonl(counter, 0);

/********************
* Support functions *
********************/
void ibwrite(int counter, const char *string) { ibwrt(counter, (char*) string, strlen(string));
}

void sleep (long mswait) {
time_t EndWait = clock() + mswait * (CLOCKS_PER_SEC/1000); while (clock() < EndWait);
}


Block Measurements (Ex. #2)
Sample program to perform fast measurements on the '9X' using block measurements. Written for National AT-GPIB/TNT for Windows NT and later.
/*
**
** Sample program to perform fast measurements on the '9X'
** using block measurements
**
** Written for National AT-GPIB/TNT for Windows NT and later
*/
#include <windows.h> #include <stdio.h> #include <time.h> #include “decl-32.h”

void ibwrite(int counter, const char *string); void sleep (long mswait);
time_t StartMain, Start, Stop, StopMain;

void main() {
int address = 10;
int i, j, counter; /* file descriptor for counter */ char bigbuf[30000], *pbuf;	char buf[100];
char	Status;

printf (“Connecting to the '9X' on address %d using National Instruments GPIB card.\n”, address);
if ((counter = ibdev(0, address, 0, T10s, 1, 0)) < 0) { printf(“Could not connect to counter”);
exit(1);
}
ibclr(counter);

do {
ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“Errors before start: %s\n”, buf);
} while (atoi(buf)!=0);

ibwrite(counter, “*idn?”);
ibrd(counter, buf, 100L); buf[ibcnt]=0;	printf(“Counter identification string: %s\n”, buf);
printf(“Setup\n”);





// Reset counter to known state	ibwrite(counter, “*rst;*cls”);

// Setup for period measurement	ibwrite(counter, “FUNC ‘PER 1’”);

// Some settings...
ibwrite(counter, “INP:LEV:AUTO OFF;:INP:LEV 0;COUP DC”);
ibwrite(counter, “TRIG:COUNT 1000;:ARM:COUNT 1");
ibwrite(counter, ”DISP:ENAB ON");	ibwrite(counter, “FORMAT ASCII;:FORMAT:TINF OFF”);
ibwrite(counter, “*ESE 1;*SRE 32");

// On the safe side: Check that setup was OK, all commands correctly spelled etc
ibwrite(counter, ”syst:err?");
ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“Setup error: %s\n”, buf);

// Measure 1000 samples Start = clock();
ibwrite(counter, “INIT;*OPC”);

// Wait for completion ibwait(counter, RQS);

/* Read status and event registers to clear them */ ibrsp(counter, &Status);
ibwrite(counter, “*ESR?”); ibrd(counter, buf, 100L);

ibwrite(counter, “FETC:ARR? 1000"); ibrd(counter, bigbuf, 30000L);
if (ibcnt >0) {
pbuf = bigbuf;
for (i=0; i<1000; i++) {
for (j=0; pbuf[j]!=’,’ && pbuf[j]!=’\0’; j++); pbuf[j]=’\0’;
if (i%50 == 0) printf(”Result %d: %s\n", i,

pbuf);

}
}
pbuf+=j+1;

Stop = clock();




printf (“Block measurement: %d samples/s\n”, 10000 * 1000 / (Stop - Start));
do {
ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“End error: %s\n”, buf);
} while (atoi(buf)!=0);

ibonl(counter, 0);
}
/********************
* Support functions *
********************/

void ibwrite(int counter, const char *string) { ibwrt(counter, (char*) string, strlen(string));
}
void sleep (long mswait) {
time_t EndWait = clock() + mswait * (CLOCKS_PER_SEC/1000);
while (clock() < EndWait);
}


Fast Measurements (Ex. #3)
Sample program to perform fast measurements on the '9X' using GET, DISP:ENAB OFF and FORMAT REAL.
Written for National AT-GPIB/TNT for Windows NT and later.

/*
**
** Sample program to perform fast measurements on the '9X'
** using GET, DISP:ENAB OFF and FORMAT REAL
**
** Written for National AT-GPIB/TNT for Windows NT and later
*/
#include <windows.h> #include <stdio.h> #include <time.h> #include “decl-32.h”

void ibwrite(int counter, const char *string); void sleep (long mswait);
time_t StartMain, Start, Stop, StopMain;

typedef union {
double d; char c[8];
} r2d;

void main() {
int address = 10;
int i, j, counter;	/* file descriptor for counter */ char reading[30];
char buf[100]; r2d Result;

printf (“Connecting to the '9X' on address %d using National Instruments GPIB card.\n”, address);
if ((counter = ibdev(0, address, 0, T10s, 1, 0)) < 0) { printf(“Could not connect to counter”);
exit(1);
}
sleep(100); ibclr(counter); sleep(100);





ibwrite(counter, “*idn?”); ibrd(counter, buf, 100L); buf[ibcnt]=0;
printf(“Counter identification string: %s\n”, buf);

printf(“Setup\n”);
if ((counter = ibdev(0, address, 0, T3s, 1, 0)) < 0) { printf(“Could not connect to counter”); exit(1);
}
// Reset counter to known state ibwrite(counter, “*rst;*cls”); ibwrite(counter, “*ESE 0; *SRE 0");

// Setup for frequency measurement ibwrite(counter, “FUNC ‘per 1’”);




dc”);
// Some settings...
ibwrite(counter, “INP:LEV:AUTO OFF;:INP:LEV .5;:inp:coup
ibwrite(counter, “TRIG:COUNT 1;:ARM:COUNT 1"); ibwrite(counter, ”ACQ:APER 1e-7");


ibwrite(counter, “DISP:ENAB OFF”);	// Disable display to get maximum speed
ibwrite(counter, “FORMAT REAL;:FORMAT:TINF OFF”);
// Floating point output, no timestamps

ibwrite(counter, “FORMAT:BORDER swap”);
// Intel byte order on results

ibwrite(counter, “ARM:LAY2:SOUR BUS;:INIT:CONT ON”);
// Bus arming

sleep(100);
// On the safe side: Check that setup was OK, all commands correctly spelled etc
do {
ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“Setup error: %s\n”, buf);
} while (atoi(buf)!=0);

printf(“Start\n”);
// Measure 1000 samples Start = clock();
for (i=0; i<1000; i++) {
ibtrg(counter);	// Generate GET signal



ibrd(counter, reading, 29L); for (j=0; j<8; j++) {
Result.c[j] = reading[3+j];
}
if (i%50 == 0) printf(“Result %d: %e\n”, i, Result.d);
}
Stop = clock();
printf (“Total time %d ms (%f samples /s)\n”, Stop- Start, (double)1000.0/(Stop-Start)*1000);

ibwrite(counter, “DISP:ENAB ON”); do {
ibwrite(counter, “syst:err?”); ibrd(counter, buf, 100L); buf[ibcnt]=0; printf(“End error: %s\n”, buf);
} while (atoi(buf)!=0);

ibonl(counter, 0);
}

/********************
* Support functions *
********************/

void ibwrite(int counter, const char *string) { ibwrt(counter, string, strlen(string));
}

void sleep (long mswait) {
time_t EndWait = clock() + mswait * (CLOCKS_PER_SEC/1000);
while (clock() < EndWait);
}


USB Communication (Ex. #4)
#include “stdio.h” #include “visa.h” #include <time.h>

#define MAX_CNT 200
void Sleep( clock_t Wait ); int main(void)
{
ViStatus Status;	// For checking errors
ViUInt32 RetCount;	// Return count from string I/O ViChar Buffer[MAX_CNT];	// Buffer for string I/O ViFindList fList;
ViChar Desc[VI_FIND_BUFLEN]; ViUInt32 numInstrs; ViSession defaultRM, Instr;

int i = 0;

// Begin by initializing the system Status = viOpenDefaultRM(&defaultRM); if (Status < VI_SUCCESS) {
printf (“Failed to initialise NI-VISA system.\n”); return -1;
}
// Look for something made by Pendulum Status = viFindRsrc(defaultRM,
“USB?*INSTR{VI_ATTR_MANF_ID==0x14EB}”,
&fList, &numInstrs, Desc); if (Status < VI_SUCCESS) {
printf (“No matching instruments found.\n”); return -1;
}
// Open communication with GPIB Device
Status = viOpen(defaultRM, Desc, VI_NULL, VI_NULL, &Instr); if (Status < VI_SUCCESS) {
printf (“Cannot communicate with instrument.\n”); return -1;
}
// Set the timeout for message-based communication Status = viSetAttribute(Instr, VI_ATTR_TMO_VALUE, 1000);

// Ask the device for identification




Status = viWrite(Instr, “*IDN?\n”, 6, &RetCount); Status = viRead(Instr, Buffer, MAX_CNT, &RetCount); Buffer[RetCount]=0;

printf(“%s\n”,Buffer);

Status = viWrite(Instr, “INIT:CONT OFF;:func ‘per’\n”, 25, &RetCount);
while( i++<10){
Status = viWrite(Instr, “init;fetc?\n”, 11, &RetCount); if (Status != VI_SUCCESS) {
printf(“Write: status = %x, i = %d\n”, Status, i);
/* Close down the system */ Status = viClose(Instr); Status = viClose(defaultRM); return 0;
}
Sleep(200);
Status = viRead(Instr, Buffer, MAX_CNT, &RetCount); if (Status != VI_SUCCESS) {
printf(“Read: status = %x, i = %d\n”, Status, i);
/* Close down the system */ Status = viClose(Instr); Status = viClose(defaultRM); return 0;
}
Buffer[RetCount]=0; printf(“%s\n”,Buffer); Sleep(25);
}
Status = viWrite(Instr, “syst:err?\n”, 10, &RetCount); Sleep(25);
Status = viRead(Instr, Buffer, MAX_CNT, &RetCount); Buffer[RetCount]=0;
printf(“%s\n”,Buffer);
/* Close down the system */ Status = viClose(Instr); Status = viClose(defaultRM); return 0;
}

void Sleep( clock_t Wait )
{	clock_t Goal;
Goal = Wait + clock(); while( Goal > clock() )
;
}


Continuous Measurements (Ex. #5)
#include <windows.h> #include <stdio.h> #include <conio.h> #include <stdlib.h> #include <float.h> #include <math.h> #include <assert.h> #include "visa.h"

// Write a null terminated string (ie, no binary data) to the
// instrument.
unsigned WriteDevice(ViSession Instr, const char *Str, int Line)
{
ViStatus Status; int Length; ViUInt32 RetLength;

assert(Str != NULL); Length = strlen(Str);
Status = viWrite(Instr, (unsigned char *)Str, Length, &RetLength);
if (Status != VI_SUCCESS) {
fprintf(stderr, "Write error: %x at line %d\n", (unsigned)Status, Line);
return((unsigned)Status);
}
assert(Length == (int)RetLength); return((unsigned)Status);
}

// Read data (may be binary) into the buffer.
unsigned ReadDevice(ViSession Instr, char *Buf, int BufLength, ViUInt32 *pActualLength, int Line)
{
ViStatus Status; assert(Buf != NULL); assert(BufLength > 0);
assert(pActualLength != NULL);

Status = viRead(Instr, (unsigned char *)Buf, BufLength, pActualLength);
if (Status != VI_SUCCESS) {
fprintf(stderr, "Read error: %x at line %d\n", (unsigned)Status, Line);
}




return((unsigned)Status);
}

#define WriteDev(Str) WriteDevice(Instr, Str,  LINE )
#define ReadDev(Buf, BufLength, pActualLength) ReadDevice(Instr, Buf, BufLength, pActualLength,  LINE )
ViSession defaultRM, Instr; void Quit()
{
(void)viClose(Instr); (void)viClose(defaultRM);
_exit(0);
}

void QuitMsg(char *Str)
{
fprintf(stderr, Str); Quit();
}

void ReportAndQuit()
{
char Buf[100]; ViUInt32 ReadLength; int Error;

// Break the measurement. (void)WriteDev("abort");
// Check if everything seems to have worked out OK. printf("Error queue:\n");
do {
if (WriteDev("syst:err?") != VI_SUCCESS) { QuitMsg("Failed to query error queue\n");
}
if (ReadDev(Buf, 100, &ReadLength) != VI_SUCCESS) { QuitMsg("Failed to read error message\n");
}
Buf[ReadLength] = 0; // Null terminate. if (sscanf(Buf, "%d", &Error) != 1) {
QuitMsg("Failed to scan error status number\n");
}
printf(Buf);
} while (Error != 0);
// Restore the instrument to a more front panel friendly
// state.




(void)WriteDev("syst:pres"); (void)viClose(Instr); (void)viClose(defaultRM);
_exit(0);
}


// command line arguments struct CmdArgs
{
bool bUSB;	// GPIB if false
unsigned int nAddr; // GPIB address. Not used for USB double Pacing;
char Func[64];	// measurement function
bool bPeriod;	// is Meas Func one of Period functions
// or one of Freq functions
double RefVal, Delta;// reference value and acceptable error
// (used to check meas results) double RefFreq;	// reference freq
};

// check if string is one of the given set. returns
// the number of matched string or -1 if no matches are found inline int CheckStr(char const *s, int nSLen, char const *Set[], int nSetSize)
{
for ( int i = 0; i < nSetSize; i++ )
if ( 0 == strncmp(s, Set[i], nSLen) && nSLen == strlen(Set[i]) )
return i; return -1;
}

// Parse command line. Format:
//	<Executable> USB|GPIB[:<Address>] [<Pacing>] [<Meas Func>]
// [<RefFreq>] [<Delta>]
bool ParseCmdArgs(CmdArgs *pArgs, int argc, char* argv[])
{
static char const *StrInterfaces[] = { "USB", "GPIB" }; static char const *StrMeasFuncs[] =
{
"PER",
"PER:BTB",
"FREQ:BTB"// <-nFirstFreq
};
static int const nFirstFreq = 2;




static int const nMeasFuncs = sizeof(StrMeasFuncs) / sizeof(StrMeasFuncs[0]);

// defaults
static int const	DefAddr = 10;
static double const DefPacing = 100e-6; // s static int const	DefMeasFunc = 2;
static double const DefRefFreq = 10e6; // Hz static double const DefDelta = 10e5; // Hz

// assign some defaults pArgs->bUSB	= true;
pArgs->nAddr	= DefAddr; pArgs->Pacing	= DefPacing;
strcpy(pArgs->Func, StrMeasFuncs[DefMeasFunc]); pArgs->bPeriod = (DefMeasFunc < nFirstFreq); pArgs->RefFreq  = DefRefFreq;
pArgs->Delta   = DefDelta;

// parse command line
bool bError = (argc < 2); // at least interface should be
// specified
for ( int i = 1, nArg = i; ! bError && i < argc; i++, nArg++
)
{
char const *s = argv[i]; switch (nArg)
{
case 1: // interface
{

// find ':' delimiter int j = 0;
for ( j = 0; 0 != s[j] && ':' != s[j]; j++ );
// check interface and read address (if any) int const nInterface = CheckStr(s, j,
StrInterfaces, 2);
if ( nInterface < 0 ) { bError = true; break; } pArgs->bUSB = (0 == nInterface);
sscanf(s + j, ":%d", &(pArgs->nAddr)); break;
}
case 2: // Pacing
{
if ( 1 == sscanf(s, "%lf", &(pArgs->Pacing)) )
{
if ( pArgs->Pacing < 50e-6 ) pArgs->Pacing =
50e-6;




break;
}
// this is not pacing. fallthrough to next arg nArg++;
}
case 3: // meas func
{
// copy Meas Func int n = strlen(s);
if ( n >= sizeof(pArgs->Func) / sizeof(pArgs->Func[0]) )
{
// func is too long bError = true; break;
}
strncpy(pArgs->Func, s, n); pArgs->Func[n] = 0;
// determine if it is period (and if it is valid
// at all)
n = CheckStr(s, n, StrMeasFuncs, nMeasFuncs); if ( n >= 0 )
{
pArgs->bPeriod = (n < nFirstFreq); break;
}
// not a function specification. fallthrough nArg++;
}
case 4: // Reference Value
{
if ( 1 != sscanf(s, "%lf", &(pArgs->RefFreq)) )
bError = true;
break;
}
case 5: // Delta
{
if ( 1 != sscanf(s, "%lf", &(pArgs->Delta)) )
bError = true;
break;
}
default:
bError = true;
}
}
// display usage string in a case of error if ( bError )




{
fprintf(stderr, "Usage:\n"
"%s USB|GPIB[:<Address>] [<Pacing>] [<Meas Func>]
[<Ref Freq>] [<Delta>]\n\n"
"Parameters description:\n"
" USB|GPIB	- selects particular bus interface,\n"
" <Address>	- (optional) instrument's GPIB
address\n"
"	(%d if omitted)\n"
" <Pacing>	- (optional) pacing time between
measurements\n"
"	(%lg s if omitted)\n"
" <Meas Func> - (optional) meas func to be used.
Possible values:\n",
argv[0], DefAddr, DefPacing);
for ( int i = 0; i < nMeasFuncs; i++ ) fprintf(stderr,
"	%s\n",
StrMeasFuncs[i]); fprintf(stderr,
"	(%s if omitted)\n", StrMeasFuncs[DefMeasFunc]);
fprintf(stderr,
" <Ref Freq> - (optional) frequency to be

measured\n"

error\n"
"	(%lg Hz if omitted)\n"
" <Delta>	- (optional) acceptable frequency
"	(%lg Hz if omitted)\n", DefRefFreq, DefDelta);

return false;
}

// convert RefVal and Delta for Period pArgs->RefVal = pArgs->RefFreq;
if ( pArgs->bPeriod )
{
pArgs->RefVal = 1 / pArgs->RefVal;
pArgs->Delta *= pArgs->RefVal * pArgs->RefVal;
}
return true;
}

// check that measurement is correct
inline bool CheckMeas(double Val, CmdArgs const &Args)
{




return (_isnan(Val) ||
Val < Args.RefVal - Args.Delta || Val > Args.RefVal
+ Args.Delta);
}

// check for keypress and exit if any inline void CheckUserCancel()
{
if ( kbhit() )
{
if ( 0 == getch() ) getch(); QuitMsg("\nCancelled by the user...\n");
}
}

// Create a buffer that should fit 10000 samples in FORMat
// PACKed.
#define BUFSIZE 170000 char Buffer[BUFSIZE];

int main(int argc, char* argv[])
{
ViStatus Status; ViUInt32 ReadLength; ViFindList fList;
ViChar Desc[VI_FIND_BUFLEN]; ViUInt32 numInstrs;
double Val; bool Failed;
int Samples, Digits, i;
 int64 TSVal, PrevTSVal, Count; char *pBuf, Command[200];

// Begin by initializing the system Status = viOpenDefaultRM(&defaultRM); if (Status != VI_SUCCESS)
{
fprintf(stderr, "Initialization failed\n"); return -1;
}
// Parse cmdline CmdArgs Args;
if ( ! ParseCmdArgs(&Args, argc, argv) )
{
viClose(defaultRM); return -1;
}




// Find the instrument if ( Args.bUSB )
{
// Look on USB for something made by Pendulum with model
// code 0x0091.
// For this sample program we'll just pick the first
// found, if any.
sprintf(Command, "USB?*INSTR{VI_ATTR_MANF_ID==0x14EB && VI_ATTR_MODEL_CODE==0x0091}");
}
else // GPIB
sprintf(Command, "GPIB::%d::INSTR", Args.nAddr);
Status = viFindRsrc(defaultRM, Command, &fList, &numInstrs, Desc);
if (Status != VI_SUCCESS)
{
fprintf(stderr, "Didn't find instrument\n"); viClose(defaultRM);
return(-1);
}
// Open communication with the device.
if (viOpen(defaultRM, Desc, VI_NULL, VI_NULL, &Instr) != VI_SUCCESS)
QuitMsg("Couldn't open connection to the instrument\n");
// Set short timeout for message-based communication (1 s) if (viSetAttribute(Instr, VI_ATTR_TMO_VALUE, 1000) !=
VI_SUCCESS)
QuitMsg("Failed to set timeout\n");
// Clear the instrument
if (viClear(Instr) != VI_SUCCESS) QuitMsg("Couldn't clear the instrument\n");

// Check IDN.
if (WriteDev("*idn?") != VI_SUCCESS) Quit();
if (ReadDev(Buffer, BUFSIZE, &ReadLength) != VI_SUCCESS) Quit();
Buffer[ReadLength] = 0; // Null terminate. printf("%s\n", Buffer);

// Initialize the instrument.
printf("Testing %s with pacing: %g\n", Args.Func, Args.Pacing);
printf("Press any key to cancel.\n"); fflush(stdout);
if (WriteDev("*cls;*rst") != VI_SUCCESS) Quit();
if (WriteDev("*ese 0;*sre 0") != VI_SUCCESS) Quit();

// Set Meas Func




sprintf(Command, "CONF:%s", Args.Func);
if (WriteDev(Command) != VI_SUCCESS) Quit();
// Do a measurement to check if all is set up OK.
if (WriteDev("inp:lev:auto off;:inp:lev 0;:form:bord swap")
!= VI_SUCCESS) Quit();
if (WriteDev("form asc;:form:tinf on") != VI_SUCCESS) Quit();
if (WriteDev("read?") != VI_SUCCESS) Quit();
if (ReadDev(Buffer, BUFSIZE, &ReadLength) != VI_SUCCESS) Quit();
Buffer[ReadLength] = 0; // Null terminate. if (sscanf(Buffer, "%lf", &Val) != 1)
QuitMsg("Failed to scan test measurement\n"); if ( CheckMeas(Val, Args) )
{
fprintf(stderr, "Bad result: %s = %g %s\n", Args.Func, Val, (Args.bPeriod ? "s" : "Hz"));
sprintf(Command, "Connect a %lg Hz signal to A and try again\n", Args.RefFreq);
QuitMsg(Command);
}

// Set the timeout for message-based communication (10 s) if (viSetAttribute(Instr, VI_ATTR_TMO_VALUE, 10000) !=
VI_SUCCESS)
QuitMsg("Failed to set timeout\n");
// Set up for "infinite" number of measurements printf("\n");
sprintf(Command, "trig:coun 1;:arm:coun inf"); if (WriteDev(Command) != VI_SUCCESS) Quit();

// set pacing. note: for freq:btb meas time is actual pacing if ( Args.bPeriod )
sprintf(Command, "trig:sour tim;:trig:tim %lg", Args.Pacing);
else
sprintf(Command, "sens:acq:aper %lg", Args.Pacing); if (WriteDev(Command) != VI_SUCCESS) Quit();

// FORMat PACKed is the recommended format for maximum fetch
// speed and for best timestamp resolution. sprintf(Command, "form pack;:form:tinf on;:disp:enab off"); if (WriteDev(Command) != VI_SUCCESS) Quit();
PrevTSVal = 0; Failed = false; Sleep(500);
// Start the measurement.
if (WriteDev("init") != VI_SUCCESS) Quit();





// Fetch the measurement results as it goes. Count = 0;
while (true)
{
CheckUserCancel();







Quit();
// The 'max' parameter means fetch as many samples as is
// currently available for fetching (but no more than
// the upper limit, which by default is 10000).
if (WriteDev("fetc:arr? max") != VI_SUCCESS) Quit();
if (ReadDev(Buffer, BUFSIZE, &ReadLength) != VI_SUCCESS)
Buffer[ReadLength] = 0; // Null terminate. pBuf = Buffer;
// Check for fetc:arr? max 'no data' marker. char *p = pBuf;
if (*p++ == '#' && *p++ == '1' && *p == '0') {
// There's no data available at the moment. Wait a
// bit with the next fetch attempt in order to avoid
// swamping the instrument with useless operations
// which could actually starve the measurement
// handling in the instrument. Sleep(20);
continue;

}
// Scan FORMat PACKed header. if (*pBuf++ != '#') {
printf("Failed to scan packed header start\n"); WriteDev("abort");
Quit();
}
Digits = *pBuf++ - '0';
if (Digits < 1 || Digits > 9) {
printf("Failed to scan packed header size\n"); WriteDev("abort");
Quit();
}
int Size = 0;
for (i=0; i<Digits; i++) {
Size = 10 * Size + (int)(*pBuf++ - '0');
}
// With format packed and format:tinf on each sample is
// a double format measurement value and a 64 bit
// integer timestamp (in ps), for a total of
// 16 bytes / sample. Samples = Size / 16;




for (i=0; i<Samples; i++) { Val = *((double*)pBuf); pBuf += 8;
if (i == 0 && _isnan(Val)) {
// Invalid value response.
printf("The instrument is apparently no longer
measuring.\n");
Failed = true; break;
}
TSVal = *(( int64*)pBuf); pBuf += 8;

// Do something with the fetched result. For this
// test just check that the measurement result seems
// reasonable and that the timestamps increase as
// they should.
if (CheckMeas(Val, Args))
printf("Bad result of measurement %lf: %g %s\n", (double)Count, Val, (Args.bPeriod ? "s" : "Hz"));
// Check that the timestamps keep increasing during
// the test run.
if (TSVal <= PrevTSVal) {
printf("Invalid timestamp, sample %lf, prev =
%lf, Cur = %lf\n",
(double)Count, (double)PrevTSVal * 1e-12, (double)TSVal * 1e-12);
}
// Check for gaps in the measurement data. This will
// happen if we try to measure faster than we can
// keep up with fetching. if (Count != 0 &&
fabs((double)(TSVal - PrevTSVal) * 1e-12 -

Args.Pacing) >




}
1.5 * Args.Pacing) { printf("Gap: %lf -> %lf\n",
(double)PrevTSVal * 1e-12, (double)TSVal * 1e-12);





%lf\n", 1e-12);
PrevTSVal = TSVal; Count++;
// Display some progress. if (Count % 10000 == 0) {
printf("Sample %.0lf, value %.8le, timestamp (double)Count, Val, (double)TSVal *

}




}
if (Failed) { break;
}
}
ReportAndQuit(); return(0);
}





Chapter 5

Instrument Model



Introduction
The figure below shows how the instru- ment functions are categorized. This in- strument model is fully compatible with the SCPI generalized instrument model.
The generalized SCPI instrument model, contains three major instrument catego- ries as shown in the following table:




















Figure 5-1	Model '9X' instrument model.
An instrument may use a combination of the above functions. The counters belong to the signal acquisition category, and only that category is described in this manual.
The instrument model in Figure 5-1 de- fines where elements of the counter lan- guage are assigned in the command hierarchy. The major signal function ar- eas are shown broken into blocks. Each of these blocks are major command sub-trees in the counter command lan- guage.
The instrument model also shows how measurement data and applied signals flow through the instrument. The model does not include the administrative data flow associated with queries, commands, performing calibrations etc.




Measurement Function Block
The measurement function block converts the input signals into an internal data for- mat that is available for formatting into GPIB bus data. The measurement func- tion is divided into three different blocks: INPut, SENSe and CALCulate. See Figure 5-2.
INPut
The INPut block performs all the signal conditioning of the input signal before it is converted into data by the SENSe block. The INPut block includes cou- pling, impedance, filtering etc.
SENSe
The SENSe block converts the signals into internal data that can be processed by the CALCulate block. The SENSe com- mands control various characteristics of the measurement and acquisition process. These include: gate time, measurement function, resolution, etc.
CALCulate
The CALCulate block performs all the necessary calculations to get the required data. These calculations include: calibra- tion, statistics, mathematics, etc.



Figure 5-2	Model '9X' measurement model.




Other Subsystems
In addition to the major functions (sub- systems), there are several other subsys- tems in the instrument model.
The different blocks have the following functions.
CALibration
This subsystem controls the calibration of the interpolators used to increase the res- olution of the counter.
DISPlay
Commands in this subsystem control what data is to be present on the display and whether the display is on or off.
FORMat
The FORMat block converts the internal data representation to the data transferred over the external GPIB interface. Com- mands in this block control the data type to be sent over the external interface.
MEMory
The MEMory block holds macro and in- strument state data inside the counter.
STATus
This subsystem can be used to get infor- mation about what is happening in the in- strument at the moment.
Synchronization
This subsystem can be used to synchro- nize the measurements with the control- ler.
SYSTem
This subsystem controls some system pa- rameters like timeout.
TEST
This subsystem tests the hardware and software of the counter and reports er- rors.
TRIGger
The trigger block provides the counter with synchronization capability with ex- ternal events. Commands in this block control the trigger and arming functions of the Timer/ Counter.


Order of Execution
All commands in the counters are sequen- tial, i.e., they are executed in the same or- der as they are received.
If a new measurement command is re- ceived when a measurement is already in progress, the measurement in progress will be aborted unless XWAI is used before the command.




MEASurement Function
In addition to the subsystems of the in- strument model, which control the instru- ment functions, SCPI has signal-oriented functions to obtain measurement results. This group of MEASure functions has a different level of compatibility and flexi- bility. The parameters used with com- mands from the MEASure group describe the signal you are going to measure. This means that the MEASure functions give compatibility between instruments, since you don’t need to know anything about
the instrument you are using. See Figure 5-3.
MEASure?
This is the most simple command to use, but it does not offer much flexibility. The MEASure? query lets the counter config- ure itself for an optimal measurement, start the data acquisition, and return the result.
CONFigure; READ?
The CONFigure command makes the counter choose an optimal setting for the specified measurement. CONFigure may cause any device setting to change.



Figure 5-3	Model '9X' measurement function.



READ? starts the acquisition and returns the result.
This sequence does the same as the MEA- Sure command, but now it is possible to insert commands between CONFigure and READ? to adjust the setting of a par- ticular function (called fine tuning). For instance, you can set an input attenuator at a required value.
CONFigure; INITiate;FETCh?
The READ? command can be divided into the INITiate command, which starts the measurement, and the FETCh? com- mand, which requests the instrument to return the measuring results to the con- troller.





Chapter 6


Using the Subsystems




Introduction
Although SCPI is intended to be self ex- planatory, we feel that some hints and tips on how to use the different subsys- tems may be useful. This chapter does not explain each and every command, but only those for which we believe extra ex- planations are necessary.





Calculate Subsystem


The calculate subsystem processes the measuring results. Here you can recalcu- late the result using mathematics, make statistics and set upper and lower limits for the measurement result. The counter itself monitors the result and alerts you when the limits are exceeded.
Mathematics
The mathematical functions are the same as on the front panel.
Statistics
The '9X' can calculate and display the MIN, MAX, MEAN and standard devia- tion of a given number of samples. The statistical functions are the same as on the front panel.
Limit Monitoring
Limit monitoring makes it is possible to get a service request when the measure- ment value falls below a lower limit or rises above an upper limit. Two status bits are defined to support limit monitor- ing. One is set when the results are greater than the UPPer limit, the other is set when the result is less than the LOWer limit. The bits are enabled using the  standard  *SRE command  and
:STAT:DREG0:ENAB. Using both these
bits, it is possible to get a service request when a value passes out of a band ( UPPer is set at the upper band border and LOWer at the lower border) OR when a measurement value enters a band (LOWer set at the upper band border and UPPer set at the lower border).
Turning the limit monitoring calculations on/off will not influence the status regis- ter mask bits which determine whether or not a service request will be generated when a limit is reached. Note that the cal- culate subsystem is automatically enabled when limit monitoring is switched on. This means that other enabled calculate sub-blocks are indirectly switched on.





Configure Function
The CONFigure command sets up the counter to make the same measurements as the MEASure query, but without initi- ating the measurement and fetching the result. Use configure when you want to change any parameters before making the measurement.
Read more about Configure under MEA- Sure.





Format Subsystem


Time Stamp Readout Format
When :FORMat:TINFormation is set to ON, the readout will consist of two val- ues instead of one for :FETCh:SCALar?,
:READ:SCALar? and :MEASure:SCA-
Lar?.
The first will be the measured value, ex- pressed in the basic unit of the measure- ment function, and the next one will be the timestamp value in seconds.
In :FORMat ASCii mode, the result will be given as a floating-point number, fol- lowed by a floating point timestamp value.
In :FORMat REAL mode, the result will be given as an eight-byte block contain- ing the floating-point measured value, followed by an eight-byte block contain- ing the floating-point timestamp value.
When doing readouts in array form, with
:FETCh :ARRay?, :READ :ARRay? or
:MEASure :ARRay?, the response will consist of alternating measurement values and timestamp values, formatted in a sim- ilar way as for scalar readout. All values will be separated by commas.
An overview of the different output for- mats can be gained by studying Chapter 8, Command Reference.
See the following subdivisions with page references:
P. 8-33 ff. — Fetch Function
P. 8-37 ff. — Format Subsystem
P. 8-73	— Measurement Function





Input Subsystems

Figure 6-1	Summary of Model ‘9X’ input amplifier settings.





Measurement Function


The Measure function group has a differ- ent level of compatibility and flexibility than other commands. The parameters used with commands from the Measure group describe the signal you are going to measure. This means that the Measure functions give compatibility between in- struments, since you don’t need to know anything about the instrument you are us- ing.

MEASure?
This is the most simple query to use, but it does not offer much flexibility. The MEASure? query lets the instrument con- figure itself for an optimal measurement, starts the data acquisition, and returns the result.
Example:
SEND MEASure:FREQ?
This will execute a frequency measurement and the result will be sent to the controller. The instrument will select a setting for this purpose by itself, and will carry out the re- quired measurement as “well” as possible; moreover, it will automatically start the measurement and send the result to the controller.
You may add parameters to give more
details about the signal you are going to measure, for example:
SEND MEASure:FREQ?-20-MHz,1
Where: 20 MHz is the expected value, which can, of course, also be sent as 20E6, and 1 is the required resolution. (1 Hz)
Also the channel numbers can be speci- fied, for example:
SEND MEASure:FREQ?-(@3)
SEND MEASure:FREQ?-20E6, 1,(@1)

CONFigure; READ?
The CONFigure command causes the in- strument to choose an optimal setting for the specified measurement. CONFigure may cause any device setting to change. READ? starts the acquisition and returns the result.
This sequence operates in the same way as the MEASure command, but now it is possible to insert commands between CONFigure and READ? to fine-tune the setting of a particular function. For exam- ple, you can change the input impedance from 1 M to 50 .




Example:
SEND CONFigure:FREQ-2E6,1
2E6 is the expected value
1 is the required resolution (1Hz) SEND INPut:IMPedance-50 Sets input impedance to 50  SEND READ?
Starts the measurement and returns the result.

CONFigure;INITiate;FETCh?
The READ? command can be divided into the INITiate command, which starts the measurement, and the FETCh? com- mand, which requests the instrument to return the measuring results to the con- troller.
Example:
SEND CONFigure:FREQ-20E6,1
20E6 is the expected signal value 1 is the required resolution
SEND INPut:IMPedance-1E6 Sets input impedance to 1 M SEND INITiate
Starts measurement
SEND FETCh?
Fetches the result






Sense Command Subsystems


Depending on application, you can select different input channels and input charac- teristics.
Switchbox
In automatic test systems, it is difficult to swap BNC cables when you need to mea- sure on several measuring points. With the '9X' you can select from two different basic inputs (A and B), on which the counter can measure directly without the need for external switching devices.
Prescaling
For all measuring functions except time interval, rise/fall time, phase and time stamping, the maximum input A or B fre- quency is 300 MHz.
For the measuring functions explicitly mentioned above, the counter has a max repetition rate of 160 MHz.
For the measuring functions Frequency and Period Average, the signal to Input A or Input B is prescaled by a factor of 2. For Frequency in Burst, PRF and Num- ber of Cycles in Burst, the signal is prescaled by a factor of 2 if the command
:SENSe:FREQuency:BURSt:PREScaler is set to ON. This is also the default condi- tion.





Status Subsystem


Introduction
Status reporting is a method to let the controller know what the counter is do- ing. You can ask the counter what status it is in whenever you want to know.
You can select some conditions in the counter that should be reported in the Sta- tus Byte Register. You can also select if some bits in the Status Byte should gen- erate a Service Request (SRQ).
(An SRQ is the instrument’s way to call the controller for help.)

Status Reporting Model
The Status Structure
The status reporting model used is stan- dardized in IEEE 488.2 and SCPI, so you will find similar status reporting in most modern instruments. Figure 6-6 shows an overview of the complete status register structure. It has four registers, two queues, and a status byte:
The Standard Event Register reports the standardized IEEE 488.2 errors and condi- tions.
The Operation Status Register reports the status of the measurement cycle (see also ARM-TRIG model, page 6-23).
The Questionable Data Register reports when the output data from the counter may not be trusted.
The Device Register 0 reports when the measuring result has exceeded prepro- grammed limits.
The Output Queue status reports if there is output data to be fetched.
The Error Queue status reports if there are error messages available in the error queue.
The Status Byte contains eight bits. Each bit shows if there is information to be fetched in the above described registers and queues of the status structure.
Using the Registers
Each status register monitors several con- ditions at once. If something happens to any one of the monitored conditions, a summary bit is set true in the Status Byte Register.
Enable registers are available so that you can select what conditions should be re- ported in the status byte, and what bits in the status byte should cause SRQ.
A register bit is TRUE, i.e., some- thing has happened, when it is set to 1. It is FALSE when set to 0.




Note that all event registers and the status byte record positive events. That is when a condition changes from inactive to ac- tive, the bit in the event register is set true. When the condition changes from active to inactive, the event register bits are not affected at all.
When you read the contents of a register, the counter answers with the decimal sum of the bits in the register.
Example:
The counter answers 40 when you ask for the contents of the Standard Event Status Register.
Convert this to binary form. It will give you 101000.
Bit 5 is true showing that a command error has occurred.



































Figure 6-2	Model ‘9X’ status register structure.




Bit 3 is also true, showing that a device dependent error has occurred.
Use the same technique when you pro- gram the enable registers.
Select which bits should be true.
Convert the binary expression to decimal data.
Send the decimal data to the instrument.
Clearing/Setting all bits
You can clear an enable register by pro- gramming it to zero. You can set all bits true in a 16-bit event enable register by programming it to 32767 (bit 16 not used).
You set all bits true in 8-bit registers by programming them to 255 (Service Re- quest Enable and Standard Event Enable.)
Using the Queues
The two queues, where the counter stores output data and error messages, may con- tain data or be empty. Both these queues have their own status bit in the Status Byte. If this bit is true there is data to be fetched.
When the controller reads data, it will also remove the data from the queue. The queue status bit in the status byte will re- main true for as long as the queue holds





























Figure 6-3	The status byte bits.




one or more data bytes. When the queue is empty, the queue status bit is set false.
Status of the Output Queue (MAV)
The MAV (message available) queue sta- tus message appears in bit 4 of the status byte register. It indicates if there are bytes ready to be read over the GPIB in the GPIB output queue of the instrument. The output queue is where the formatted data appears before it is transferred to the controller.
The controller reads this queue by ad- dressing the instrument as a talker. The command to do this differs between dif- ferent programming languages. Examples are IOENTERS and IBREAD.
Status of the Error Message Queue (EAV)
The EAV (error message available) queue status message appears in bit 2 of the status byte register. Use the
:SYSTem:ERRor? query to read the er- ror messages. Chapter 7 explains all pos- sible error messages .
Using the Status Byte
The status byte is an eight bit status mes- sage. It is sent to the controller as a re- sponse to a serial poll or a *STB? query, see Figure 6-3. Each bit in the status byte contains a summary message from the status structure. You can select what bits in the status byte should generate a ser- vice request to alert the controller.
When a service request occurs, the SRQ-line of the GPIB will be activated. Whether or not the controller will react on the service request depends on the controller program. The controller may be interrupted on occurrence of a service
request, it may regularly test the SRQ-line, it may regularly make serial poll or *STB?, or the controller may not react at all. The preferred method is to use SRQ because it presents a minimum of disturbance to the measurement pro- cess.
Selecting Summary Message to Gen- erate SRQ
The counter does not generate any SRQ by default. You must first select which summary message(s) from the status byte register should give SRQ. You do that with the Service Request Enable com- mand *SRE <bit mask>.
Example:
*SRE-16
This sets bit 4 (16=24) in the service request enable register (see Figure 6-4). This makes the instrument signal SRQ when a message is available in the output queue.
RQS/MSS
The original status byte of IEEE 488.1 is sent as a response to a serial poll, and bit 6 means requested service, RQS.
IEEE 488.2 added the *STB? query and expanded the status byte with a slightly different bit 6, the MSS. This bit is true as long as there is unfetched data in any of the status event registers.
The Requested Service bit, RQS, is set true when a service request has been signalled. If you read the status byte via a Serial Poll, bit 6 represents RQS. Reading the status byte with a serial poll will set the RQS bit false, showing that the status byte has been read.
The Master Summary Status bit, MSS, is set true if any of the bits that generates




SRQ is true. If you read the status byte us- ing *STB?, bit 6 represents MSS. MSS re- mains true until all event registers are cleared and all queues are empty.
Setting up the Counter to Report Status
Include the following steps in your pro- gram when you want to use the status re- porting feature.
*CLS Clears all event registers and the er- ror queue
*ESE <bit mask> Selects what condi- tions in the Standard Event Status register should be reported in bit 5 of the status byte
:STATus:OPERation:ENABle <bit mask> Selects which conditions in the Operation Status register should be re- ported in bit 7 of the status byte
:STATus:QUEStionable:ENABle
<bit mask> Selects which conditions in the Questionable Status register should be reported in bit 3 of the status byte
:STATus:DREGister0:ENABle
<bit mask> Selects which conditions in Device Register 0 should be reported in bit 0 of the status byte
*SRE <bit mask> Selects which bits in the status byte should cause a Service Request
A programming example using status re- porting is available in Chapter 7.
Reading and Clearing Status
Status Byte
As explained earlier, you can read the status byte register in two ways:
Using the Serial Poll (IEEE-488.1 de- fined).
Response:
Bit 6: RQS message, shows that the counter has requested service via the SRQ signal.
Other bits show their summary mes- sages
A serial poll sets the RQS bit FALSE, but does not change other bits.

Using the Common Query *STB?
Response:
Bit 6: MSS message, shows that there is a reason for service request.
Other bits show their summary mes- sages.
Reading the response will not alter the status byte.


Status Event Registers
You read the Status Event registers with the following queries:
*ESR? Reads the Standard Event Status register
:STATus:OPERation? Reads the Operation Status Event register
:STATus:QUEStionable? Reads the Questionable Status Event register
:STATus:DREGister0? Reads the Device Event register
When you read these registers, you will clear the register you read and the sum- mary message bit in the status byte.




You can also clear all event registers with the *CLS (Clear Status) command.
Status Condition Registers
Two of the status register structures also have condition registers: The Status Op- eration and the Status Questionable regis- ter.
The condition registers differ from the event registers in that they are not latched. That is, if a condition in the counter goes on and then off, the condi- tion register indicates true while the con- dition is on and false when the condition goes off. The Event register that monitors the same condition continues to indicate true until you read the register.
:STATus:OPERation:CONDition? Reads the Operation Status Condition reg- ister
:STATus:QUEStionable:CONDi- tion? Reads the Questionable Status Condition register
Reading the condition register will not af- fect the contents of the register.
Why Two Types of Registers?
Let’s say that the counter measures con- tinuously and you want to monitor the measurement cycle by reading the Opera- tion Status register.
Reading the Event Register will always show that a measurement has started, that waiting for triggering and bus arming has occurred and that the measurement is stopped. This information is not very use- ful.
Reading the Condition Register on the other hand gives only the status of the
measurement cycle, for instance “Mea- surement stopped”.
Although it is possible to read the condition registers directly, we recommend that you use SRQ when monitoring the measure- ment cycle. The measurement cycle is disturbed when you read condition registers.
Summary:
The way to work when writing your bus program is as follows:
Set up
Set up the enable registers so that the events you are interested in are summa- rized in the status byte.
Set up the enable masks so that the condi- tions you want to be alerted about generate SRQ. It is good practice to generate SRQ on the EAV bit. So, enable the EAV-bit via
*SRE.
Check & Action
Check if an SRQ has been received.
Make a serial poll of the instruments on the bus until you find the instru- ment that issued the SRQ (the instru- ment that has RQS bit true in the Sta- tus Byte).
When you find it, check which bits in the Status Byte Register are true.
Let’s say that bit 7, OPR, is true. Then read the contents of the Opera- tion Status Register. In this register you can see what caused the SRQ.
Take appropriate actions depending on the reason for the SRQ.




Standard Status Registers
These registers are called the standard status data structure because they are mandatory in all instruments that fulfill the IEEE 488.2 standard.
Standard Event Status Register
Bit 7 (weight 128) — Power-on (PON)
Shows that the counter’s power supply has been turned off and on (since the last time the controller read or cleared this register).
Bit 6 (weight 64)—User Request (URQ)
Shows that the user has pressed a key on the front panel. The URQ bit will be set regardless of the remote local state of the counter. The purpose of this signal is, for
example, to call for the attention of the controller by generating a service request.

Figure 6-5	Bits in the standard event
status register



Figure 6-4	Standard status data structures, overview.




Bit 5 (weight 32) — Command Error (CME)
Shows that the instrument has detected a command error. This means that it has re- ceived data that violates the syntax rules for program messages.
Bit 4 (weight 16) — Execution Error (EXE)
Shows that the counter detected an error while trying to execute a command. (See ‘Error reporting’ on page 3-17.) The command is syntactically correct, but the counter cannot execute it, for example because a parameter is out of range.
Bit 3 (weight 8) — Device-dependent Error (DDE)
A device-dependent error is any device operation that did not execute properly because of some internal condition, for instance error queue overflow. This bit shows that the error was not a command, query or execution error.
Bit 2 (weight 4) — Query Error (QYE)
The output queue control detects query er- rors. For example the QYE bit shows the unterminated, interrupted, and deadlock conditions. For more details, see ‘Error re- porting’ on page 3-17.
Bit 1 (weight 2)—Request Control (RQC)
Shows the controller that the device wants to become the active control- ler-in-charge. Not used in this counter.
Bit 0 (weight 1) — Operation Complete (OPC)
The counter only sets this bit TRUE in response to the operation complete com- mand (*OPC). It shows that the counter
has completed all previously started ac- tions.
Summary, Standard Event Status Reporting
*ESE <bit mask>
Enable reporting of Standard Event Sta- tus in the status byte.
*SRE 32
Enable SRQ when the Standard Event structure has something to report.
ESR?
Reading and clearing the event register of the Standard Event structure.



SCPI-defined Status Registers
The counter has two 16-bit SCPI-defined status structures: The operation status register and the questionable data regis- ter. These are 16 bits wide, while the sta- tus byte and the standard status groups are 8 bits wide.



























Figure 6-6	Status structure 7, Operation Status Group, and Status structure 3, Questionable Data Group are SCPI defined.




Operation Status Group
This group reports the status of the coun- ter measurement cycle.

Figure 6-7	Bits in the Opeation Sta-
tus Register.


Bit 8 (weight 256) — Measurement Stopped (MSP)
This bit shows that the counter is not mea- suring. It is set when the measurement, or sequence of measurements, stops.
Bit 6 (weight 64) — Wait for Bus Arm- ing (WFA)
This bit shows that the counter is waiting for bus arming in the arm state of the trig- ger model.
Bit 5 (weight 32) — Waiting for Trigger and/or External Arming (WFT)
This bit shows when the counter is ready to start a new measurement via the trigger control option (488.2), for the shortest possible trigger delay. The counter is now in the wait for the trigger state of the trig- ger model.
Bit 4 (weight 16) — Measurement Started (MST)
This bit shows that the counter is measur- ing. It is set when the measurement or se- quence of measurements starts.
Summary, Operation Status Reporting
:STAT:OPER:ENAB
Enable reporting of Operation Status in the status byte.
*SRE 128
Enable SRQ when operation status has someting to report.
:STAT:OPER?
Reading and clearing the event register of the Operation Status Register structure
:STAT:OPER:COND?
Reading the condition register of the Op- eration Status Register structure.




Questionable Data/Signal Status Group
This group reports when the output data from the counter may not be trusted.

Figure 6-8	Bits in Questionable data register.


Bit 14 (weight 16384) — Unexpected Parameter (UEP)
This bit shows that the counter has re- ceived a parameter that it cannot execute, although the parameter is valid according to SCPI. This means that when this bit is true, the instrument has not performed a measurement exactly as requested.
Bit 10 (weight 1024) — Timeout for Measurement (TIO)
The counter sets this bit true when it abandons the measurement because the internal timeout has elapsed, or no signal has been detected.
See	also	:SYST:TOUT	and
:SYST:SDET.
Bit 8 (weight 256) Overflow (OFL)
The counter sets this bit true when it can- not complete the measurement due to overflow.
Summary, Questionable Data/Signal Status Reporting
:STAT:QUES:ENAB <bit mask>
Enable reporting of Questionable data/signal status in the status byte.
*SRE 8
Enable SRQ when data/signal is ques- tionable.
:STAT:QUES?
Reading and clearing the event register of the Questionable data/signal Register structure.
:STAT:QUES:COND?
Reading the condition register of Ques- tionable data/signal Register structure.



Device-defined Status Structure

The counter has one device-defined status
structure called the Device Register 0. It summarizes this structure in bit 0 of the
status byte. Its purpose is to report when
the measuring result has exceeded pre- programmed limits.









	





Operation Status Register	Device Register 0
Condition Register

Event Register

Enable Register

Logical OR



7 6 5 4
3 2 1
0 Status Byte Register


Service Request Enable

Logical OR


SRQ signal
Figure 6-9	Device-defined status data structures ( model ).




You set the limits with the following commands in the calculate subsystem.
:CALCulate:LIMit:UPPer and
:CALCulate:LIMit:LOWer

Bit Definition


Figure 6-10	Bits in the Device Status
Register number 0.
:STATus:DREGister0? Reads out the contents of the Device Status event Register 0 and clears the register.

Bit 2 (weight 4) — Monitor of Low Limit
This bit is set when the low limit is passed from above.
Bit 1 (weight 2) — Monitor of High Limit
This bit is set when the high limit is passed from below.
Summary, Device-defined Status Reporting
:STAT:DREG0:ENAB <bit mask>
Enable reporting of device-defined status in the status byte.
*SRE 1
Enable SRQ when a limit is exceeded.
:STAT:DREG0?
Reading and clearing the event register of Device Register structure 0.
If bit 1 is true, the high limit has been ex- ceeded.
If bit 2 is true, the low limit has been ex- ceeded.

Power-on Status Clear
Power-on clears all event enable registers and the service request enable register if the power-on status clear flag is set TRUE  (see  the  common  command
*PSC.)
Preset the Status Reporting Structure
You can preset the complete status struc- ture to a known state with a single com- mand, the STATus:PRESet command, which does the following:
Disables all bits in the Standard Event Register, the Operation Status Register, and the Questionable Data Register
Enables all bits in Device Register 0
Leaves the Service Request Enable Regis- ter unaffected.





Trigger/Arming Subsystem


The SCPI TRIGger subsystem enables syn- chronization of instrument actions with specified internal or external events. The following list gives some examples.

Instrument Action
Some examples of events to synchronize with are as follows:
measurement
bus trigger
external signal level or pulse
10 occurrences of a pulse on the external trigger input
other instrument ready
signal switching
input signal present
1 second after input signal is present
sourcing output signal
switching system ready
The ARM-TRIG Trigger Configuration
gives a typical trigger configuration, the ARM-TRIG model. The configuration contains two event-detection layers: the ‘Wait for ARM’ and ‘Wait for TRIG’ states.


Figure 6-11	Generalized ARM-TRIG model.



This trigger configuration is sufficient for most instruments. More complex instru- ments, such as the '9X', have more ARM layers.
The ‘Wait for TRIG’ event-detection layer is always the last to be crossed be- fore instrument actions can take place.


Structure of the IDLE and INITIATED States
When you turn on the power or send
*RST or :ABORT to the instrument, it sets the trigger system in the IDLE state; see Figure 6-12.
The trigger system will exit from the IDLE state when the instrument receives an INITiate:IMMediate. The in- strument will pass directly through the INITIATED state downward to the next event-detection layers (if the instrument contains any more layers).
The trigger system will return to the INI- TIATED state when all events required by the detection layers have occurred and the instrument has made the intended measurement. When you program the trigger system to INITiate:CONTin- uous ON, the instrument will directly exit the INITIATED state moving down- ward and will repeat the whole flow de- scribed	above.	When INITiate:CONTinuous is OFF, the trigger system will return to the IDLE state.





Figure 6-12  Flow diagram of IDLE
and INITIADED layers.

Structure of an Event-detection Layer
The  general  structure  of  all event-detection layers is identical and is roughly depicted by the flow diagram in .
In each layer there are several program- mable conditions, which must be satisfied to pass by the layer in a downward direc- tion:
Forward Traversing an Event-detection Layer
After initiating the loop counters, the in- strument waits for the event to be de- tected. You can select the event to be detected by using the <layer>:SOURce command. For example:
:ARM:LAYer2:SOURce BUS
You can specify a more precise character- istic of the event to occur. For example:
:ARM:LAYer:DELay 0.1
You may program a certain delay be- tween the occurrence of the event and en- tering into the next layer (or starting the device actions when in the TRIGger




layer). This delay can be programmed by using the <layer>:DELay command.
Backward Traversing an Event-detection Layer
The number of times a layer event has to initiate a device action can be pro- grammed by using the <layer>:COUNt command. For example:
:TRIGger:COUNt 3 causes the in- strument to measure three times, each measurement being triggered by the spec- ified events.
Triggering
*TRG Trigger Command
The trigger command has the same func- tion as the Group Execute Trigger com- mand GET, defined by IEEE 488.1.
When to use *TRG and GET
The *TRG and the GET commands have the same effect on the instrument. If the Counter is in idle, i.e., not parsing or exe- cuting any commands, GET will execute much faster than *TRG since the instru- ment must always parse *TRG.




Arming Start Layer 2 (bus trig)

















Arming Start Layer 1 (External control)











Trigger Start Layer 1 (Number of measurements on each arm)

Figure 6-13	Structure of event detection layers.




Chapter 7

Error Messages




Read the Error/Event Queue
You read the error queue with the :SYS- Tem:ERRor? query.
Example:
SEND :SYSTem:ERRor?
READ –100, “Command Error”
The query returns the error number fol- lowed by the error description.
If more than one error occurred, the query will return the error that occurred first. When you read an error, you will also re- move it from the queue. You can read the next error by repeating the query. When you have read all errors, the queue is
empty,  and  the  :SYSTem:ERRor?
query will return:
0, “No error”
When errors occur and you do not read these errors, the Error Queue may over- flow. Then the instrument will overwrite the last error in the queue with:
–350, “Queue overflow”
If more errors occur they will be dis- carded.
Read more about how to use er- ror reporting in the Introduction to SCPI chapter





































































This page is intentionally left blank.




Chapter 8

Command Reference


















This page is intentionally left blank.


Abort













:ABORt

:ABORt
Abort Measurement
The ABORt command terminates a measurement. The trigger subsystem state is set to “idle-state”. The command does not invalidate already finished results when breaking an array measurement. This means that you can fetch a partial result af- ter an abort.
Type of command:
Aborts all previous measurements if *WAI is not used.














Complies with standards:	SCPI 1991.0, confirmed.


Arming Subsystem


:ARM
[ :STARt | :SEQuence [ 1 ] ]
:LAYer2
:[ IMMediate ]
:SOURce	- BUS | IMMediate
[ :LAYer [ 1 ] ]
:COUNt	- <Numeric value> | MIN | MAX | INF *
:DELay	- <Numeric value> | MIN | MAX
:SLOPe	- POSitive | NEGative
:SOURce	- EXTernal1 | EXTernal2 | External4 | IMMediate
:STOP | :SEQuence2

[ :LAYer [ 1 ] ]
:SLOPe	- POSitive | NEGative
:SOURce	- EXTernal1 | EXTernal2 | EXTernal4 | TIMer | IMMediate
:TIMer	- <Numeric value> | MIN | MAX
* The INFinity parameter is only accepted by the CNT-91

:ARM :COUNt
- <Numeric value>|MIN|MAX|INFinity *
No. of Measurements on each Bus arm
This count variable controls the upward exit of the “wait-for-bus-arm” state (:ARM:STARt:LAY1). The counter loops the trigger subsystem downwards COUNt number of times before it exits to the idle state.
This means that a COUNt No. of measurements can be done for each Bus arming or INITiate.
The actual number of measurements made on each INIT is equal to:
(:ARM:START:COUNT)*(:TRIG:START:COUNT)


Parameters:
<Numeric value> is an integer between 1 and 2 147 483 647 (231-1). (The integer 1 switches the function OFF.)
MIN gives 1
MAX gives 2 147 483 647
* CNT-91 only: INFinity makes the arm loop continue indefinitely, or rather until other de- vice-dependent parameters set limits. In practice, timestamping will probably collapse after more than 100 days of non-aborted operation. The INFinity parameter is mainly
intended for continuous measurements, i.e. without defined end, where intermediate re- sults can be fetched on the fly.
Returned format:  <Numeric value>|INF*
Example:
SEND→ :ARM:COUN-100J
*RST condition:	1






















Complies with standards:	SCPI 1991.0, confirmed




Delay after External Start Arming
:ARM :DELay
- <Numeric value> | MIN | MAX

This command sets a delay between the pulse on the selected arming input and the time when the counter starts measuring.
Range: 20 ns to 2 s, 10 ns resolution. Parameters:
<Numeric value> is a number between 20*10–9 and 2 s. MIN gives 0 which switches the delay OFF.
MAX gives 2 s
Returned format:  <Numeric value>J
Example:
SEND→ :ARM:DEL -0.1J
*RST condition:  0




Complies with standards:	SCPI 1991.0, confirmed.


:ARM :LAYer2

Bus Arming Override
This command overrides the waiting for bus arm, provided the source is set to bus. When this command is issued, the counter will immediately exit the “wait-for-bus- arm” state.
The counter generates an error if it receives this command when the trigger sub- system is not in the “wait-for-bus-arm” state.
If the Arming source is set to Immediate, this command is ignored.
Example:
SEND→ :ARM:LAY2J











Complies with standards:	SCPI 1991.0, confirmed.

:ARM :LAYer2 :SOURce
- «BUS | IMMediate»
Bus Arming On/Off
Switches between Bus and Immediate mode for the “wait-for-bus-arm” function, (layer 2). GET and *TRG triggers the counter if Bus is selected as source.
If the counter receives GET/ *TRG when not in “wait-for-bus-arm” state, it ignores the trigger and generates an error.
It also generates an error if it receives GET/ *TRG and bus arming is switched off (set to IMMediate).
Returned format:  BUS|IMMJ
Example:
SEND→ :ARM:LAY2:SOUR - BUSJ









Complies with standards:	SCPI 1991.0, confirmed.

:ARM :SLOPe
- «POSitive|NEGative»
External Arming Start Slope
Sets the slope for the start arming condition.
Returned format:  POS|NEGJ
Example:
SEND→ :ARM:SLOP - NEGJ
*RST condition:  POS


















Complies with standards:	SCPI 1991.0, confirmed.




External Start Arming Source
:ARM :SOURce
- «EXTernal1 | EXTernal2 | EXTernal4 | IMMediate»

Selects START arming input or switches off the start arming function. When switched off the DELay is inactive.
Parameters:
EXTernal1 is input A EXTernal2 is input B EXTernal4 is input E IMMediate is Start arming OFF
Note: For the Totalize function in the CNT-91, IMM means manual start-stop using the commands :TOT:GATE - ON|OFFJ
Returned format:  EXT1 | EXT2 | EXT4 | IMMJ
Example:
SEND→ :ARM:SOUR - EXT4J
*RST condition:  IMM



Complies with standards:	SCPI 1991.0, confirmed.


External Stop Arming Slope
Sets the slope for the stop arming condition.
Returned format:  POS|NEGJ
Example:
SEND→ :ARM:STOP:SLOP - NEGJ
*RST condition:  POS


















Complies with standards:	SCPI 1991.0, confirmed.

:ARM :STOP :SLOPe
- «POSitive | NEGative»

:ARM :STOP :SOURce
- «EXTernal1 | EXTernal2 | EXTernal4 | TIMer | IMMediate»
External Stop Arming Source
Selects STOP arming input or switches off the STOP arming function. The CNT-91 has also a programmable timer that is accessible in Totalize mode.
Parameters:
EXTernal1 is input A EXTernal2 is input B EXTernal4 is input E
TIMe is timed STOP in Totalize measurements (CNT-91 only). The time is set with the command :ARM:STOP:TIM - <stop delay time>.
IMMediate is Stop arming OFF
Returned format:  EXT1 | EXT2 | EXT4 | TIM | IMMJ
Example:
SEND→ :ARM:STOP:SOUR - EXT4J
*RST condition:  IMM




Complies with standards:	SCPI 1991.0, confirmed.

:ARM :STOP :TIMer
- <Numeric value> | MIN | MAX
Setting Gate Time in Timed Totalize Measurements
This command sets a delay between a pulse on the selected start arming input, i.e. when totalizing starts, and the point of time when totalizing stops.
Range: 20 ns to 2 s, 10 ns resolution. Parameters:
<Numeric value> is a number between 20*10 -9 and 2 s. MIN gives 20*10 -9 s.
MAX gives 2 s
Returned format:  <Numeric value>J
Example:
SEND→ :ARM:STOP:TIM - 0.1J
*RST condition:  0


Calculate Subsystem

:CALCulate
:STATe	- ON|OFF
:DATA?
:IMMediate
:MATH
[:EXPRession]	- (<Numeric expression>)
:STATe	- ON|OFF
:AVERage
[:STATe]	- ON|OFF
:TYPE	- MIN|MAX|MEAN|SDEViation|ADEViation *
:COUNt	- <Numeric value>|MIN|MAX
:CURRent?
:LIMit
[:STATe]	- ON|OFF
:FAIL?
:CLEar
[:IMMediate]
:AUTO	- ON|OFF
:FCOunt
[:TOTal]?
:LOWer?
:TOTal?
:UPPer?
:PCOunt[:TOTal]?
:UPPer
[:DATA]	- <Numeric value>|MIN|MAX
:STATe	- ON|OFF
:LOWer
[:DATA]	- <Numeric value>|MIN|MAX
:STATe	- ON|OFF
:TOTalize
:TYPE	- APLUSB|AMINUSB|ADIVB
☞ * Totalize Manual can not be used together with the Statistics functions.

:CALCulate :AVERage :ALL?
The Main Calculated Statistics Parameters
Returns mean value, standard deviation, min and max value from the current sta- tistics sampling.
Returned format:  <mean value>, <standard deviation>, <min value>, <max value>J

















:CALCulate :AVERage :COUNt
- < No. of samples>
Sample Size for Statistics
Sets the number of samples to use in statistics sampling.
Parameters:  <No. of samples> is an integer in the range 2 to 2*10 .

Returned format:  < No. of samples>J

*RST condition:	100

Number of Statistics Samples Gathered
Returns the number of samples currently gathered in the current statistics sam- pling.
Returned format:  <No. of samples>J






















Enable Statistics
:CALCulate :AVERage :STATe
- < Boolean >

Switches On/Off the statistical function. Note that the CALCulate subsystem is au- tomatically enabled when the statistical functions are switched on. This means that other enabled calculate sub-blocks are indirectly switched on. The statistics must be enabled before the measurements are performed. When the statistical function is enabled, the counter will keep the trigger subsystem initiated until the
:CALC:AVER:COUNT variable is reached. This is done without any change in the trigger subsystem settings. Consider that the trigger subsystem is programmed to perform 1000 measurements when initiated. In such a case, the counter must make 10000 measurements if the statistical function requires 9500 measurements because the number of measurements must be a multiple of the number of mea- surements programmed in trigger subsystem (1000 in this example).
Parameters
<Boolean> = ( 1/ON | 0/OFF )
Returned format:  1|0J
*RST condition:	OFF

You cannot combine Statistics with array readouts, so if you want to store and fetch individual values in a block measurement, you have to make sure the de- fault command :CALC:AVER:STATE OFF is active.

:CALCulate :AVERage :TYPE
- «MAX|MIN|MEAN|SDEViation|ADEViation»
Statistical Type
Selects the statistical function to be performed.
You must use :CALC:DATA? to read the result of statistical operations. :READ?,
:FETC? will only send the results that the statistical operation is based on.
Parameters:
MAX returns the max. value of all samples taken under :CALC:AVER control. MIN returns the min. value of all samples taken under :CALC:AVER control.

MEAN returns the mean value of the samples taken: x =
N
 Σ Xi

N i =1

SDEV returns the standard deviation: s =



ADEV returns the Allan deviation σ= 

Returned format:  MAX|MIN|MEAN|SDEV|ADEVJ
*RST condition:	MEAN

:CALCulate :DATA?
Fetch calculated data
Fetches data calculated in the post processing block. Use this command to fetch the calculated result without making a new measurement.
Returned Format:
<Decimal data>J

Example:
SEND→ :CALC:MATH:STAT-ON;:CALC:MATH-(((1-*-X)---10.7E6)-/-1)
;:init; *OPC
Wait for operation complete
SEND→ :CALC:DATA?
READ← <Measurement - result - minus - 10.7E6>
*RST condition:
Event, no *RST condition.






Complies with standards:	SCPI 1991.0, Confirmed

Recalculate Data
This event causes the calculate subsystem to reprocess the statistical function on the sense data without reacquiring the data. Query returns this reprocessed data.
Returned format:  <Decimal data>J
Where: <Decimal data> is the recalculated data.
Example:
SEND→ :CALC:AVER:STAT - ON;TYPE - SDEV;:INIT;*OPC
Wait for operation complete
SEND→ :CALC:DATA?
READ← <Value - of - standard - deviation>
SEND→ :CALC:AVER:TYPE - MEAN
SEND→ :CALC:IMM?
READ← <Mean - value>
*RST condition:	Event, no *RST condition.





Complies with standards:	SCPI 1991.0, Confirmed.


Enable Monitoring of Parameter Limits
Turns On/Off the limit-monitoring calculations.

:CALCulate :LIMit
- <Boolean>

Limit monitoring makes it is possible to get a service request when the measure- ment value falls below a lower limit, or rises above an upper limit.
Two status bits are defined to support limit-monitoring. One is set when the results are greater than the UPPer limit, the other is set when the result is less than the LOWer limit. The bits are enabled using the standard *SRE command and
:STAT:DREG0:ENAB. Using both these bits, it is possible to get a service request when a value passes out of a band ( UPPer is set at the upper band border and
LOWer at the lower border) OR when a measurement value enters a band (LOWer set at the upper band border and UPPer set at the lower border).
Turning the limit-monitoring calculations On/Off will not influence the status register mask bits, which determine whether or not a service request will be generated when a limit is reached. Note that the calculate subsystem is automatically enabled when limit-monitoring is switched on. This means that other enabled calculate
sub-blocks are indirectly switched on. Parameters <Boolean> = ( 1/ON | 0/OFF ) Returned format: 1|0J
*RST condition:	OFF
See also:  Example 1 in Chapter 4 deals with limit-monitoring.
Complies with standards:	SCPI 1991.0, confirmed.

:CALCulate :LIMit :CLEar
Clear Limit Failure Count
The command resets the counter that reports its result over the
:CALCulate:LIMit:FCOunt? query command.


















:CALCulate :LIMit :CLEar :AUTO
- <Boolean>
Automatic Reset of Limit Failure Count
The command activates (ON) or deactivates (OFF) automatic reset by :INIT of the counter that reports its result over the :CALCulate:LIMit:FCOunt? query command.
Parameters  <Boolean> = ( 1/ON | 0/OFF )
*RST condition:	OFF

Limit Fail
Returns a 1 if the limit testing has failed (the measurement result has passed the limit), and a 0 if the limit testing has passed.
The following events reset the fail flag:
Power-on
*RST
A:CALC:LIM:STAT-OFF → :CALC:LIM:STAT-ON transition
Reading a 1 with this command.

Returned format:  1| 0J
Example:
SEND→ SENS:FUNC-‘FREQ’;:CALC:LIM:STAT-ON;:CALC:LIM:UPPER
-1E3;READ?;*WAI;:CALC:LIM:FAIL?
READ← 1
if frequency is above 1kHz, otherwise 0



Complies with standards:	SCPI 1991.0, confirmed.

:CALCulate :LIMit :FCOunt :LOWer?
Number of Limit Failure Counts
The command returns the number of times the set lower limit has been passed since the counter was last reset by :CALC:LIM:CLEAR or automatically by :INIT if :CALC:LIM:CLEAR:AUTO ON has been activated.
Returned format:  < No. of counts>J

:CALCulate :LIMit :FCOunt?
Number of Limit Failure Counts
The command returns the total number of times the set lower and upper limits have been passed since the counter was last reset by :CALC:LIM:CLEAR or auto- matically by :INIT if :CALC:LIM:CLEAR:AUTO ON has been activated.
In other words, the returned value is the sum of the values returned by :CALCu- late:LIMit:FCOunt:LOWer? and :CALCulate:LIMit:FCOunt:UPPer?
Returned format:  < No. of counts>J













:CALCulate :LIMit :FCOunt :UPPer?
Number of Limit Failure Counts
The command returns the number of times the set upper limit has been passed since the counter was last reset by :CALC:LIM:CLEAR or automatically by :INIT if :CALC:LIM:CLEAR:AUTO ON has been activated.
Returned format:  < No. of counts>J

Number of Pass Counts
The command returns the number of measurement results between the set lower and upper limits since the counter was last reset by :CALC:LIM:CLEAR or auto- matically by :INIT if :CALC:LIM:CLEAR:AUTO ON has been activated..
Returned format:  < No. of counts>J





















Set Low Limit
:CALCulate :LIMit :LOWer
- «<Decimal data>|MAX|MIN»

Sets the value of the ‘Lower Limit’ , i.e., the lowest measurement result allowed be- fore the counter generates a 1 that can be read with :CALCulate:LIMit:FAIL?, or by reading the corresponding status byte.
Parameters
Parameter range: –9.9*10+37 to +9.9*10+37.
Returned format:  < Decimal data>J
*RST condition:	0















Complies with standards:	SCPI 1991.0, confirmed.

:CALCulate :LIMit :LOWer :STATe
- <Boolean>
Check Against Lower Limit
Selects if the measured value should be checked against the lower limit.
Parameters  <Boolean> = ( 1/ON | 0/OFF )

Returned format: 1| 0 J

*RST condition:	0

















Complies with standards:	SCPI 1991.0 confirmed.

:CALCulate :LIMit :UPPer
- «<Decimal data>|MAX|MIN»
Set Upper Limit
Sets the value of the ‘Upper Limit’, i.e., the highest measurement result allowed before the counter generates a 1 that can be read with :CALCu- late:LIMit:FAIL?, or by reading the corresponding status byte.
Parameters
Range: –9.9*10+37 to +9.9*10+37
Returned format:  <Decimal data>J
*RST condition:	0















Complies with standards:	SCPI 1991.0, confirmed.




Check Against Upper Limit
:CALCulate :LIMit :UPPer :STATe
- <Boolean>

Selects if the measured value should be checked against the upper limit.
Parameters  <Boolean> = ( 1/ON | 0/OFF )

Returned format: 1| 0 J

*RST condition:	0












Complies with standards:	SCPI 1991.0, confirmed.


Select Mathematical Expression

:CALCulate :MATH
- (<expression>)

Defines the mathematical expression used for mathematical operations.
☞ The data type <expression data> must be typed within parentheses.
Parameters
<expression> is one of the following five mathematical expressions:
((K-*-X)-+-L) or ((K-/-X)-+-L) or (((K-*-X)-+-L)-/-M) or
(((K-/-X)-+-L)-/-M) or ((X-/-M)---1) No deviations are allowed.
K, L and M can be any positive or negative numerical constant. Each operator must be surrounded by space characters.
Example
SEND→:CALC:MATH - (((64 - * - X) - + - -1.07e7) - / - 1e6)


*RST condition:
K=1, L=0, M=1 (( 1 * X ) + 0 )


(No calculation)

Returned format:  <expression>J



Complies with standards:	SCPI 1991.0 Confirmed.

:CALCulate :MATH :STATe
- <Boolean>
Enable Mathematics
Switches on/off the mathematical function. Note that the CALCulate subsystem is automatically enabled when MATH operations are switched on. This means that other enabled calculate sub-blocks are indirectly switched on. Switching off mathe- matics, however, does not switch off the CALCulate subsystem.
Parameters:
<Boolean> = ( 1/ON | 0/OFF )
Returned format:  1|0
Example
SEND→:CALC:MATH:STAT - 1
This example switches on mathematics.
*RST condition:	OFF










Complies with standards:	SCPI 1991.0, confirmed.

:CALCulate :STATe
- <Boolean>
Enable Calculation
Switches on/off the complete post-processing block. If disabled, neither mathemat- ics or limit-monitoring can be done.
Parameter
<Boolean> = ( 1/ON | 0/OFF )
Example
SEND→ :CALC:STAT - 1
Switches on Post Processing.
Returned format:  1|0J
RST condition:  OFF












Complies with standards:	SCPI 1991.0, Confirmed

:CALCulate :TOTalize :TYPE
- APLUSB|AMINUSB|ADIVB
Select Postprocessing for Totalize
If both counting registers (primary and secondary channel) are being used, you can manipulate the measurement results before presentation by selecting one of three postprocessing formulas that operate directly on the raw data.
Parameters
APLUSB selects the expression A+ B to add the results in the two registers.
AMINUSB selects the expression A- B to subtract the value in register B from the value in register A.
ADIVB selects the expression A/ B to calculate the ratio of the contents in regis- ters A and B.
Example
SEND→ :CALC:TOT:TYPE ADIVB
Selects the formula A / B.
Returned format:  APLUSB|AMINUSB|ADIVBJ
*RST condition:






















This page is intentionally left blank.


Calibration Subsystem


:CALibration
:INTerpolator
:AUTO	- <Boolean>

:CALibration :INTerpolator :AUTO
- <Boolean>
Calibration of Interpolator
The '9X' is a reciprocal counter that uses an interpolating technique to increase the resolution. In time measurements, for example, interpolation increases the resolu- tion from 10 ns to 0.1 ns.
The counter calibrates the interpolators automatically once for every measurement when this command is ON. When this command is OFF, the counter does no cali- brations but uses the values from the last preceding calibration. The intention of this command is to turn off the auto calibration for applications that dump measure- ments into the internal memory. This will increase the measurement speed.
Parameters
<Boolean> = ( 1 | ON / 0 | OFF )
Returned format:  1|0J
*RST condition:  ON


Configure Function


Set up Instrument for Measurement

:CONFigure
[:SCALar]<Measuring Function>	- <Parameters>,(<Channels>)]
:ARRay<Measuring Function>	- (<Array Size>)[,<Parameters>,(<Channels>)]




The array size for :MEASure and :CONFigure, and the channels, are expression data that must be in parentheses ( ).
Measuring Function, Parameters and Channels are explained on page 8-54.
The counter uses the default Parameters and Channels when you omit them in the command.

:CONFigure :<Measuring Function>
[- <parameters>[,(<channels>)]]
Configure the counter for a single measurement
Use the configure command instead of the measure query when you want to change other settings, for instance, the input settings before making the measure- ment and fetching the result.
The :CONFigure command controls the settings of the Input, Sense and Trigger sub- systems in the counter in order to make the best possible measurement. It also switches off any calculations with :CALC:STATE - OFF.
:READ? or :INITiate;:FETCh? will make the measurement and read the resulting measured value.
Since you may not know exactly what settings the counter has chosen to configure itself for the measurement, send an *RST before doing other manual set up mea- surements.
Parameters
<Measuring Function>, <Parameters> and <Channels> are defined on page 8-54. The optional parameter :SCALar means that one measurement is to be done.
Returned format:  <String>J
<String> contains the current measuring function and channel. The response is a
<String data element> containing the same answer as for [:SENSe]:FUNC- tion?.

Example:
SEND→ :CONF:FREQ:RAT-(@3),(@1)
Configures the counter for freq. ratio C/A.
See also:  ‘Explanations of the Measuring Functions’ starting on page 8-59.




















Complies with standards:	SCPI 1991.0, confirmed.

Command Reference 8-28



:CONFigure :ARRay :<Measuring Function>
- (<array size>)[,<parameters> [,(<channels>)]]
Configure the counter for an array of measurements
The :CONFigure:ARRay command differs from the :CONFigure command in that it sets up the counter to perform the number of measurements you choose in the <array size>.
To perform the selected function, you must trigger the counter with the :READ:AR- Ray? or :INITiate;:FETCh:ARRay? queries.
Parameters <array size> sets the number of measurements in the array. See table be- low.
<Measuring Function>, <Parameters>, and <Channels> are defined on page 8-54.
Example:
SEND→ :CONF:ARR:PER - (7),5E–3,1E–6,(@4)
This example sets up the counter to make seven period measurements. The ex- pected result is 5 ms, and the required resolution is 1 µs. The EXT ARM input is the measuring input.
To make the measurements and fetch the seven measurement results: SEND→ :READ:ARR? - 7
READ← 5.23421E-3,5.12311E-3,5.87526E-3, -
5.50345E-3,5.33901E-3,5.25501E-3, - 5.03571E-3


Note: To find out the maximum number in your particular case, do the following:
Make all settings not affected by CONFigure
Send :CONF:ARR:<meas. func> MAX,(@<channel>)
Send Query :TRIG:COUN? to see the maximum number of samples for this measurement


Complies with standards:	SCPI 1991.0, confirmed.

:CONFigure :TOTalize [:CONTinuous]
[- (@«1|2»)][,(@«1|2»)]
Totalize Manually
This is a count/totalize function controlled from the GPIB interface using the com- mand SENS:TOT:GATE-ON|OFF.
The counter counts up for each event on the primary input channel. The same ap- plies to the secondary channel if it has been activated. The result is one or two val- ues depending on the presence of the secondary channel. In addition to selecting totalizing, the :CONF:TOT:CONT command also selects positive trigger slope. If you want to count negative slopes on input A, send :INPut:SLOPe- NEG after the :CONF:TOT:CONT command. The results of successive ON-OFF periods are accumulated.
Postprocessing of two-channel results is done by means of the :CALCulate com- mand. See page 8-23. Arming is used for realizing non-manual functions like Tot A gated by B or Tot A-B timed. See page 8-10.
Parameters
(@«1|2») is the primary channel:
,(@«1|2») is the secondary channel:
(@1) stands for input A (@2) stands for input B
This measurement cannot be made as a :MEASure, it must be made as a
:CONFigure followed by :INIT:CONT-ON, gate control with :SENS:TOT:GATE
«ON|OFF» and completed with a :FETCh:ARR? <array size>.
Example:
SEND→ :CONF:TOT;:INP:SLOPe NEG
This example sets up the counter to totalize the negative slopes on Input A and disable the secondary channel. (Same as (@1))
*RST condition  (@1),(@2)

Intermediate results
When totalizing you often want to read intermediate results without stopping the totalizing process. :FETC:ARR?-–1 always outputs the current register value.


Display Subsystem













:DISPlay

:ENABle - ON OFF

:DISPlay :ENABle
- < Boolean >
Display State
Turns On/Off the updating of the entire display section. This can be used for secu- rity reasons or to improve the GPIB speed, since the display does not need to be updated.
Parameters:  <Boolean> = (1 / ON | 0 / OFF)
Returned format: 1|0 J
*RST condition:	ON

















Complies with standards:	SCPI 1991.0, confirmed.


Fetch Function











:FETCh

[:SCALar]?
:ARRay? - <Array Size>|MAX *


* CNT-91 only

:FETCh?
Fetch One Result
The fetch query retrieves one measuring result from the measurement result buffer of the counter without making new measurements. Fetch does not work unless a measurement has been made by the :INITiate, :MEASure?, or :READ? com- mands.
If the counter has made an array of measurements, :FETCh? fetches the first measuring results first. The second :FETCh? fetches the second result and so on. When the last measuring result has been fetched, fetch starts over again with the first result.
The same measuring result can be fetched again and again, as long as the result is valid, i.e., until the following occurs:
*RST is received.
an :INITiate, - :MEASure or :READ command is executed
any reconfiguration is done.
an acquisition of a new reading is started.
If the measuring result in the output buffer is invalid but a new measurement has been started, the fetch query completes when a new measuring result becomes valid. If no new measurement has been started, an error is returned.
The optional :SCALar means that one result is retrieved.
Returned format:  <data>J
The format of the returned data is determined by the format commands :FORMat
and :FORMat:BORDer. See also examples on page 8-39.


Val = measurement value (double precision in REAL and PACKed)
TS = timestamp value (double precision in REAL and int64 ps in PACKed)
If no valid result can be returned, e.g. due to time-out, the returned data will de- pend on the chosen GPIB mode according to the table under :FETCh:ARRay?





Complies with standards:	SCPI 1991.0, confirmed.




Fetch an Array of Results
:FETCh :ARRay?
- <fetch array size>|MAX *

:FETCh:ARRay? query differs from the :FETCh? query by fetching several mea- suring results at once.
An array of measurements must first be made by the commands. :INITiate,
:MEASure:ARRay? or :CONFigure:ARRay;:READ?
If the array size is set to a positive value, the first measurement made is the first result to be fetched.
When the counter has made an array of measurements, :FETCh:ARRay? - 10 fetches the first 10 measuring results from the output queue. The second
:FETCh:ARRay? - 10 fetches the result 11 to 20, and so on. When the last mea- suring result has been fetched, fetch:array starts over again with the first result.
In totalizing for instance, you may want to read the last measurement result instead of the first one. This is possible if you set the array size to a negative number. Ex- ample: :FETCh:ARRay? - –5 fetches the last five results. The output queue pointer is not altered when the array size is negative. That is, the example above always gives the last five results every time the command is sent.
:FETCh:ARRay? - –1 is useful to fetch intermediate results in free-running or ar- ray measurements without interrupting the measurement.

Parameters
:ARRay means that an array of retrievals is made for each :FETCh command.
<fetch array size> is the number of retrievals in the array. This number must not exceed the number of results in the measurement result buffer. The maximum limit is 10000 due to the physical size of the output buffer.
* CNT-91 only: MAX means that all the results in the output buffer will be fetched.

Returned format:  <data>[,<data>]J
The format of the returned data is determined by the format commands :FORMat
and :FORMat:FIXed.

Example:
If :MEAS:ARR:FREQ? - (4) gives the results 1.1000,1.2000,1.3000,1.4000
:FETC:ARR - 2  fetches the results 1.1000,1.2000
:FETC:ARR - 2  once more fetches the results 1.3000,1.4000
:FETC:ARR - –1  always fetches the last result 1.4000

Val = measurement value (double precision in REAL and PACKed)
TS = timestamp value (double precision in REAL and int64 ps in PACKed)
If no valid result can be returned, e.g. due to time-out, the returned data will de- pend on the chosen GPIB mode according to the table below.


NaN = Not a Number, a standardized bit pattern indicating that the transferred data is not a valid result.


You cannot combine Statistics with array readouts, so if you want to store and fetch individual values in a block measurement, you have to make sure the default command :CALC:AVER:STATE OFF is active.
A ‘FETC:ARR? MAX’ during an ongoing array measurement will fetch as many samples as currently available for immediate fetch (but no more than 10000).
Note 1: With no new measurements since the last fetch, and a measurement still in progress, the result will be ‘data corrupt or stale’, otherwise it will wrap to the begin- ning. This is not an error as such, just indicating a fact.
Note 2: When format packed is used and the size is not known in advance, the data header looks a bit different from normal, e.g. a single value with a timestamp will look like ‘#6000016<16 data bytes>’ instead of ‘#216<16 data bytes>’.













Complies with standards:	SCPI 1991.0, confirmed.


Format Subsystem



:FORMat
[:DATA]	- ASCii | REAL | PACKed
:BORDer	- NORMal | SWAPped
:SMAX	- <Numeric value> *
:TINFormation[:STATe]	- <Boolean>
* CNT-91 only

:FORMat
- ASCii|REAL|PACKed
Response Data Type
Sets the format in which the result will be sent on the bus.
Parameters:
ASCii: The length will be automatically controlled by the resolution of each measurement re- sult.
REAL: The length parameter is ignored; the output is always in 8-byte format. PACKed: See REAL.
Returned format:  ASC|REAL|PACKJ
*RST condition:	ASCii
See also:  :FORMat:TINFormation and :FETCh? commands







Complies with standards:	SCPI 1991.0, confirmed.

:FORMat :BORDer
- NORMal|SWAPped
Response Byte Order
Sets the order in which response data bytes formatted as REAL or PACKED are sent on the bus.
Parameters:
NORMal: Response data is sent with the MSB first and the LSB last (big-endian order) SWAPped: Response data is sent with the LSB first and the MSB last (little-endian order)
Returned format:  NORM|SWAPJ
*RST condition:  NORMal
See also:  :FORMat command




Upper Limit for Array Size
:FORMat :SMAX
- <Numeric value>

Sets or queries the upper limit for :FETCh:ARRay? MAX command in number of samples. The command is intended for use with any controllers or application pro- grams that cannot read large amounts of data, when the functionality of the
:FETCh:ARRay? MAX command is still interesting.
Parameter:  Integer N, where 4 c N c 10000
Returned format:  <Numeric value)J
Power ON default value:  10000
*RST condition:  Not affected

Format Examples:
The response formats for REAL and PACKed are described on page 8-34, but also depend on the setting of FORMAT:BORDer. If you are using an Intel platform, you will either have to swap all bytes, or set FORMAT:BORDER SWAP to get lit-
tle-endian byte order as opposed to the normal big-endian order.
Here is a sample with the same measurement result in various formats:
FORMAT ASCII
+4.9999999999E+05,+7.6433000000000E+02\n
FORMAT:BORDER SWAP;:FORMAT REAL;:FETC?
23 31 38 ad 74 fd ff 7f 84 1e 41 2c 23 31 38 71 3d 0a d7 a3 e2 87 40 0a
The bit pattern is interpreted as #18<Val>,#18<TS>\n. Val and TS are 64-bit dou- ble precision floating point numbers, least significant byte first.
FORMAT:BORDER SWAP;:FORMAT PACK;:FETC?
23 32 31 36 ad 74 fd ff 7f 84 1e 41 00 24 24 72 27 b7 02 00 0a
The bit pattern is interpreted as #216<Val><TS>\n. Val is a 64-bit double precision floating point number, while TS is a 64 bit integer with number of picoseconds since a reference time, least significant byte first.
FORMAT:BORDER NORM;:FORMAT REAL;:FETC?
23 31 38 41 1e 84 7f ff fd 74 ad 2c 23 31 38 40 87 e2 a3 d7 0a 3d 71 0a
The bit pattern is interpreted as #18<Val>,#18<TS>\n. Val and TS are 64-bit dou- ble precision floating point numbers, most significant byte first.
FORMAT:BORDER NORM;:FORMAT PACK;:FETC?
23 32 31 36 41 1e 84 7f ff fd 74 ad 00 02 b7 27 72 24 24 00 0a
The bit patttern is interpreted as #216<Val><TS>\n. Val is a 64-bit double precision floating point number, while TS is a 64 bit integer with number of picoseconds since a reference time, most significant byte first.

:FORMat :TINFormation
- Boolean
Timestamping On/Off
This command turns on/off the time stamping of measurements. Time stamping is always done at the start of a measurement with full measurement resolution, and is saved in the measurement buffer together with the measurement result.
The setting of this command will affect the output format of the MEASure, READ and FETCh queries. See the FETCH function on page 8-33 ff.
For :FETCh:SCALar?, :READ:SCALar? and :MEASure:SCALar? the readout will con- sist of two values instead of one. The first will be the measured value and the next one will be the timestamp value.
In :FORMat ASCii mode, both the measured value and the timestamp value will be given as floating-point numbers expressed in the basic units (e.g. Hz - s or s - s).
In :FORMat REAL mode, the result will be given as an eight-byte block containing the floating-point measured value, followed by an eight-byte block containing the floating point timestamp value.
In :FORMat PACKed mode, the result will be given as an eight-byte block contain- ing the floating-point measured value followed by an eight-byte block containing the timestamp value expressed as a 64-bit integer (int64), the implicit unit being ps.
When doing readouts in array form, with :FETCh :ARRay?, :READ :ARRay?, or
:MEASure :ARRay? , the response will consist of alternating measurement values and timestamp values, formatted in a similar way as for scalar readout. All values will be separated by commas. See also the :MEASure:ARRay:TSTAmp? command on page 8-73 for more information on the output format.
Parameters  <Boolean> = (1 / ON | 0 / OFF)

Returned format: 1|0 J

*RST condition:	OFF


Hard Copy






:HCOPy
:SDUMp
:DATA?

:HCOPy :SDUMp :DATA?
Screen Dump
Return block data containing screen dump in Windows BMP format.
Returned Format:
#43942<Binary BMP Data>
The '4' means that the following four digits (3942) tell how many data bytes will succeed. The proper screen data is preceded by a 62-byte header, which means that 3942 - 62 = 3880 bytes carry the pixel information. The number of pixels is consequently 3880 x 8 = 31040. The display geometry is 320 x 97 = 31040.


Initiate Subsystem




:INITiate
[:IMMediate ]
:CONTinuous - ON | OFF

:INITiate
Initiate Measurement
The :INITiate command initiates a measurement. Executing an :INITiate command changes the counter’s trigger subsystem state from “idle-state” to “wait-for-bus-arm-state” (see Figure 6-11). The trigger subsystem will continue to the other states, depending on programming. With the *RST setting, the trigger subsystem will bypass all its states and make a measurement, then return to idle state. See also ‘How to use the Trigger Subsystem’ at the end of this chapter.















Complies with standards:	SCPI 1991.0, confirmed.

:INITiate :CONTinuous
- <Boolean>
Continuously Initiated
The trigger system could continuously be initiated with this command. When Con- tinuous is OFF, the trigger system remains in the “idle-state” until Continuous is set to ON or the :INITiate is received. When Continuous is set to ON, the comple- tion of a measurement cycle immediately starts a new trigger cycle without entering the “idle-state”, i.e., the counter is continuously measuring and storing response data.
Returned format:  1|0J
*RST condition:	OFF















Complies with standards:	SCPI 1991.0, confirmed.


Input Subsystems

INPUT A
:INPut[1]
:ATTenuation	- <Numeric value>|MIN|MAX (1|10)
:COUPling	- AC|DC
:IMPedance	- <Numeric value>|MIN|MAX
[:EVENt]
:LEVel	- <Numeric value>|MIN|MAX
:AUTO	- ON|OFF|ONCE
:RELative	- <Numeric value>
:SLOPe	- POS|NEG
:FILTer
[:LPASs]
[:STATe]	- ON|OFF
:DIGital	- ON|OFF
:FREQuency	- <Numeric value>|MIN|MAX
INPUT B
:INPut2
:ATTenuation	- <Numeric value>|MIN|MAX (1|10)
:COUPling	- AC|DC
:IMPedance	- <Numeric value>|MIN|MAX
[:EVENt]
:LEVel	- <Numeric value>|MIN|MAX
:AUTO	- ON|OFF|ONCE
:RELative	- <Numeric value>
:SLOPe	- POS|NEG
:FILTer
[:LPASs]
[:STATe]	- ON|OFF
:DIGital	- ON|OFF
:FREQuency	- <Numeric value>|MIN|MAX

INPUT E
:INPut4
[:EVENt]
:SLOPe	- POS|NEG

:INPut«[1]|2» :ATTenuation
- «<Numeric value>|MAX|MIN»
Attenuation
Attenuates the input signal by 1 or 10. The attenuation is automatically set if the in- put level is set to AUTO.
Parameters:
<Numeric values> c 5, and MIN gives attenuation 1.
<Numeric values> > 5, and MAX gives attenuation 10.
Returned format:
1.00000000000E+000|1.00000000000E+001 J
Example for Input A (1)
SEND :INP:ATT - 10
Example for Input B (2)
SEND→ :INP2:ATT - 10
*RST condition Input A (1) and Input B (2): 1 (but set by autotrigger since AUTO is on af- ter *RST. (:INP:LEV:AUTO - ON).





Complies with standards:	SCPI 1991.0, confirmed.

:INPut«[1]|2» :COUPling
- «AC|DC»
AC/DC Coupling
Selects AC coupling (normally used for frequency measurements), or DC cou- pling (normally used for time measurements).
Returned format:  AC|DCJ
Example for Input A (1)
SEND→ :INP:COUP - DC
Example for Input B (2)
SEND→ :INP2:COUP - AC

*RST condition
Input A (1): AC Input B (2): AC






Complies with standards:	SCPI 1991.0, confirmed.




Analog Low Pass Filter
:INPut«[1]|2» :FILTer
- <Boolean>

Switches on or off the analog low pass filter on input 1 (A) and/or input 2 (B). It has a cutoff frequency of 100 kHz.
Parameters:
<Boolean> is «1 | ON» | «0 | OFF»
Returned format:  1|0J
*RST condition  OFF

















Complies with standards:	SCPI 1991.0, confirmed.

:INPut«[1]|2» :FILTer :DIGital
- <Boolean>
Digital Low Pass Filter
Switches on or off the digital low pass filter on input 1 (A) and/or input 2 (B). The cutoff frequency is set by the command:
:INPut«[1]|2»:FILTer:DIGital:FREQuency-<Numeric value>
Parameters:
<Boolean> is «1 | ON» | «0 | OFF»
Returned format:  1|0J
*RST condition:  OFF

:INPut«[1]|2» :FILTer :DIGital :FREQuency
-<Numeric value>|MIN|MAX
Set the Digital Low Pass Filter Cutoff Frequency
Any frequency between 1 Hz and 50 MHz can be entered. The filter is activated by the command:
:INPut«[1]|2»:FILTer:DIGital-ON|OFF
Parameters:
<Numeric value> is a value between 1 and 50*106 MIN means 1 Hz
MAX means 50 MHz
Returned format:  <Numeric value>J
*RST condition:  100 kHz









:INPut«[1]|2» :IMPedance
- «<Decimal data>|MAX|MIN»
Input Impedance
The impedance can be set to 50 Ω or 1 MΩ.
Parameters
MIN or <Decimal data> that rounds off to 50 or less, sets the input impedance to 50 
MAX or <Decimal data> that rounds off to 1001 or more, sets the impedance to 1 MΩ.
Returned format:
5.00000000000E+001|1.00000000000E+6J
Example for Input A (1)
SEND→ :INP:IMP - 50
Sets the input A impedance to 50 Ω.
Example for Input B (2)
SEND→ :INP2:IMP - 50
Sets the input B impedance to 50 Ω.
*RST condition  1 MΩ





Complies with standards:	SCPI 1991.0, confirmed.




Fixed Trigger Level
:INPut«[1]|2» :LEVel
- «<Decimal data>|MAX|MIN»

Input A and input B can be individually set to autotrigger or to fixed trigger levels of between –5 V and +5 V in steps of 2.5 mV. If the attenuator is set to 10X, the range is –50 V and +50 V in 25 mV steps. Setting an absolute trigger level turns off autotrigger for the selected channel.
For autotrigger, see the next command.
Parameters: <Decimal data> is a number between –5 V and +5 V if att = 1X and be- tween –50 V and +50 V if att = 10X.
MAX gives +5 V or +50 V and MIN gives –5 V or -50 V, depending on the attenuator setting. See above.
Returned format:  <Decimal data>J
Example for Input A (1)
SEND→ :INP:LEV - 0.01
Example for Input B (2)
SEND→ :INP2:LEV - 2.0
*RST condition  0 (but controlled by Autotrigger since AUTO is on after *RST)







Autotrigger
:INPut«[1]|2» :LEVel :AUTO
- «<Boolean> | ONCE»

If set to AUTO, the counter automatically controls the trigger level.
The autotrigger function normally sets the trigger levels to 50 % of the signal ampli- tude. A few exceptions exist, however:
A:
Rise/Fall time measurements: Here the Input 1 (A) trigger level is set to 10% resp. 90% and the Input 2 (B) trigger level is set to 90% resp. 10% of the amplitude.
B:
Frequency and Period Average mode: The input trigger levels are set to 70% re- spectively 30% of the amplitude.
C:
Functions for which AUTO does not work are Frequency or Period Back-to-Back, Time Interval Error (TIE) and Totalize. If one of these is selected, an AUTO ONCE is performed instead.
ONCE means that the counter makes one automatic calculation of the trigger level at the beginning of a measurement. This value is then fixed until another
level-setting command is sent to the counter, or until a new measurement is initiated.

In this way you can benefit from the automatic trigger level adjustment without sac- rificing measurement speed.

☞ From the bus, input A and input B are always set to autotrigger individually.
Parameters:
<Boolean> = ( 1/ON | 0/OFF | ONCE)
Example for Input A (1)
SEND→ :INP:LEV:AUTO - OFF
Example for Input B (2)
SEND→ :INP2:LEV:AUTO - ON
Returned format:  1|0|ONCEJ
*RST condition:  ON







:INPut«[1]|2» :LEVel :RELative
- <Numeric value>
Relative Trigger Level
When autotrigger is active, the relative trigger levels are normally fixed at values that depend on the selected function, for instance 10% (Inp A) and 90% (Inp B) for Rise Time, 50% (Inp A & Inp B) for Time Interval, 70% (Inp A) and 30% (Inp B) for Frequency. At times you may want to change these values. Since the default val- ues are restored automatically after changing function, this command may have to be sent repeatedly. The two input channels are programmed separately and are consequently not interdependent.
The command itself does not switch on autotrigger, so if you want to set relative levels after having used abolute levels, you must also send the command
:INP:LEV:AUTO ON (see above), unless you have changed measurement func- tion.
Parameters
<Numeric value> is a positive number between 0 and 100 (%).
Example
SEND→ :INP:LEV:REL - 20 (Inp A set to 20% to measure ECL rise time) SEND→ :INP2:LEV:REL - 80 (Inp B set to 80% to measure ECL rise time)
Returned format:  <Numeric value>J
*RST condition:  Depending on function (see description above).




Trigger Slope
:INPut«[1]|2» :SLOPe
- «POS|NEG»

Selects if the counter should trigger on a positive or a negative transition. Selecting negative slope is useful for Time Interval measurements.
The slope is fixed for Pos/Neg Pulse Width/Duty Factor and Rise/Fall Time. Arming slope is not affected by this command. Use :ARM:STARt:SLOPe and
:ARM:STOP:SLOPe instead.


Returned format:  POS | NEG J
Example for Input A (1)
SEND→ :INP:SLOP - POS
Example for Input B (2)
SEND→ :INP2:SLOP - NEG

*RST condition  POS




Complies with standards:	SCPI 1991.0, confirmed.






















This page is intentionally left blank.


Measurement Function


Set up the Instrument, Perform Measurement, and Read Data

:MEASure
[:SCALar]<Measuring Function>? [<Parameters>][,(<Channels>)]
:ARRay<Measuring Function>?	- (<Array Size>)[,<Parameters>][,(<Channels>)]
:MEMory?	- [<N>]
:MEMory<N>?




The array size for :MEASure and :CONFigure, and the channels, are expression data that must be within parentheses ( ).
The question mark at the end of the commands is only valid for :MEASure, where a result is expected. It must be deleted for :CONFigure, which is a set- ting command only.
The default channels, which the counter use when you omit the channels in the command, are printed in italics in the channel list on the following pages.
If you want to check what function and channels the counter is currently using, send :CONF?
This query gives the same answer as :FUNC? in the SENSe subsystem

:MEASure|:CONFigure [:SCALar]
[:VOLTage]
:FREQuency
[:CW]?	[ _ [<exp. value>[,<resol.>],][(@1|@2|@3|@4|@6)]]
:BTBack? *	[ _ [<exp. value>[,<resol.>],][(@1|@2)]]
:BURSt?	[ _ [<exp. value>[,<resol.>],][(@1|@2|@3)]]
:POWer[:AC]? **	[ _ (@3)]
:PRF?	[ _ [<exp. value>[,<resol.>],][(@1|@2|@3)]]
:RATio?	[ _ [<exp. value>[,<resol.>],][(@1|@2|@3),(@1|@2|@3)]]
:NCYCles?	[ _ (@1|@2|@3)]
:PDUTycycle|:DCYCle?[ _ [<reference>,][(@1|@2)]]
:NDUTycycle?	[ _ [<reference>,][(@1|@2)]]
:MAXimum?	[ _ (@1|@2)]
:MINimum?	[ _ (@1|@2)]
:PTPeak?	[ _ (@1|@2)]
:RATio?	[ _ (@1|@2),(@1|@2)]
:PSLEwrate?	[ _ (@1|@2)]
:NSLEwrate?	[ _ (@1|@2)]
:PERiod?	[ _ [<exp. value>[,<resol.>],][(@1|@2|@3)]]
:BTBack? *	[ _ [<exp. value>[,<resol.>],][(@1|@2)]]
:PERiod:AVERage?	[ _ [<exp. value>[,<resol.>],][(@1|@2|@3)]]
:PHASe?	[ _ [<exp. value>[,<resol.>],][(@1|@2),(@1|@2)]]
«:RISE:TIME|:RTIM»? [ _ [<lo thresh.>[,<hi thresh.>[,<exp. value>[,<resol.>]]],][(@1|@2)]]
«:FALL:TIME|:FTIM»? [ _ [<lo thresh.>[,<hi thresh.>[,<exp. value>[,<resol.>]]],][(@1|@2)]]
:TINTerval?	[ _ [<exp. value>[,<resol.>],][(@1|@2),(@1|@2)]]
:PWIDth?	[ _ [<reference>,][(@1|@2)]]
:NWIDth?	[ _ [<reference>,][(@1|@2)]]
:TOTalize?	_
:[CONTinuous] ***  [ _ [(@1|@2)][,(@1)|@2)]]



(@1) means input A (@2) means input B
(@3) means input C (RF input option) (@4) means the rear panel arming input (@6) means the internal reference
*  CNT 91 only
** CNT-90XL only
*** CNT-91 only, in combination with :CONFigure, not :MEASure

:ARRay
[:VOLTage]
:FREQuency
[:CW]?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2|@3|@4|@6)]]
:BTBack? *	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:BURSt?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2|@3)]]
:POWer[:AC]? **	_ (<Size>)[,(@3)]
:PRF?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2|@3)]]
:RATio?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2|@3),(@1|@2|@3)]]
:NCYCles?	_ (<Size>)[,(@1|@2|@3)]
:PDUTycycle|:DCYCle? _ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:NDUTycycle?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:MAXimum?	_ (<Size>)[,(@1|@2)]
:MINimum?	_ (<Size>)[,(@1|@2)]
:PTPeak?	_ (<Size>)[,(@1|@2)]
:RATio?	_ (<Size>)[,(@1|@2),(@1|@2)]
:PSLEwrate?	_ (<Size>)[,(@1|@2)]
:NSLEwrate?	_ (<Size>)[,(@1|@2)]
:PERiod?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2|@3)]]
:BTBack? *	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:PERiod:AVERage?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2|@3)]]
:PHASe?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2),(@1|@2)]]
«:RISE:TIME|:RTIM»?  _ (<Size>)[,[<lo thresh.>[,<hi thresh.>[,<exp. value>[,<resol.>]]],][(@1|@2)]]
«:FALL:TIME|:FTIM»?  _ (<Size>)[,[<lo thresh.>[,<hi thresh.>[,<exp. value>[,<resol.>]]],][(@1|@2)]]
:TIError?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:TINTerval?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2),(@1|@2)]]
:PWIDth?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:NWIDth?	_ (<Size>)[,[<exp. value>[,<resol.>],][(@1|@2)]]
:STSTamp?	_ (<Size>)[,(@1|@2)]
:TSTAmp?	_ (<Size>)[,(@1|@2)]
:TOTalize?	_
:[CONTinuous] ***  [ _ [(@1|@2)][,(@1)|@2)]]


(@1) means input A (@2) means input B
(@3) means input C (RF input option) (@4) means the rear panel arming input (@6) means the internal reference
* CNT-91 only
** CNT-90XL only
*** CNT-91 only, in combination with :CONFigure, not :MEASure

:MEASure :<Measuring Function>?
[- [<parameters>][ ,(<channels>)]]
Make one measurement
The measure query makes a complete measurement, including configuration and readout of data. Use measure when you can accept the generic measurement without fine tuning.
When a CONFigure command or MEASure? query is issued, all counter settings are set to the *RST settings., except those specified as <parameters> and
<channels> in the CONFigure command or MEASure? query.
The :MEASure? query is a compound query identical to:
:ABORt;:CONFigure:<Meas_func>;:READ?
Parameters:
<Measuring Function>, <Parameters> and <Channels> are defined on page 8-54. You may omit <parameters> and <Channels>, which are then set to default.
Returned format:  <data>J
Where: The format of the returned data is determined by the format commands: :FORMat and
:FORMat:FIXed.
Example:
SEND→ :MEAS:FREQ? - (@3)
READ← 1.78112526833E+009

This example measures the frequency on the C-input and outputs the result to the controller.
Type of command:  Aborts all previous measurement commands if *WAI is not used.
See also:  ‘Explanations of the Measuring Functions’ starting on page 8-59.




















Complies with standards:	SCPI 1991.0, confirmed.



:MEASure :ARRay :<Measuring Function>?
- (<array size>)[,[<parameters>] [,(<channels>)]]
Make an array of measurements
The :MEASure:ARRay query differs from the :MEASure query in that it performs the number of measurements you decide in the <array size> and sends all the measuring results in one string to the controller.
The array size for :MEASure and :CONFigure, and the channels, are expression data that must be in parentheses ( ).
The :MEASure:ARRay query is a compound query identical to:
:ABORt;:CONFigure:ARRay:<Meas-func> - (<array-size>); :READ:ARRay? -
(<array-size>)
Parameters:
<array size> sets the number of measurements in the array. The maximum number is limited to 10000 due to the physical size of the output buffer. See also FETCH:ARR? and READ:ARR?
Returned format:
<Measuring result>{[,<measuring result>]}J
Example:
SEND→ :MEAS:ARR:FREQ? - (10)
Ten measuring results will be returned.

Type of command:
Aborts all previous measurement commands if not *WAI is used, see page 8-142 .























Complies with standards:	SCPI 1991.0, confirmed.

:MEASure :MEMory<N>?
Memory Recall, Measure and Fetch Result
Use this command when you want to measure several parameters fast.
:MEAS:MEM1? recalls the contents of memory 1 and reads out the result,
:MEAS:MEM2? recalls the contents of memory two and reads out the result etc.
The equivalent command sequence is *RCL1;READ?
The allowed range for <N> is 1 to 9. Use the somewhat slower
:MEAS:MEMory?-N command described below if you must use memories 10 to 19.
Returned format:
<measurement result>J










Complies with standards:	SCPI 1991.0, confirmed

:MEASure :MEMory?
- <N>
Memory Recall, Measure and Fetch Result

Same as above command but somewhat slower. Allows use of all memories (1 to 19).
Example: :MEAS:MEM - 13
This example recalls the instrument setting in memory number 13, makes a meas- urement, and fetches the result.













Complies with standards:	SCPI 1991.0, confirmed

EXPLANATIONS OF THE MEASURING FUNCTIONS


This sub-chapter explains the various measurements that can be done with :MEASure and :CONFigure;:READ?. Only the queries for single measurements using the measure command are given here, but all of the information is also valid for the :CONFigure command and for both scalar (single) and array measurements.

:MEASure :FREQuency?
[- [<expected value>[,<resolution>]] [,<(@«1|2|3|4|6»)>]]
Frequency
Traditional frequency measurements. The counter uses the <expected value> and
<resolution> to calculate the Measurement Time (:SENSe:ACQuisition:APER- ture).
Example:
SEND→ :MEAS:FREQ? - (@3)
READ← 1.78112526833E+009
This example measures the frequency at input C.
☞ The channel is expression data and it must be in parentheses ( ).
Parameters:
<expected value> is the expected frequency,
<resolution> is the required resolution.
<(@«1|2|3|4|6»)> is the channel to measure on: (@1) means input A1
(@2) means input B1
(@3) means input C (RF input option)
(@4) means input E (Rear panel arming input) (@6) means the internal reference

If you omit the channel, the instrument measures on input A (@1).
1 These channels are prescaled by 2 when measuring frequency, and prescaled by 1 for all other functions. An exception is burst frequency measurements, where you can choose between the two factors. See the next command and the command
:SENSe:FREQuency:PREScaler:STATe on page 8-94. There is a tradeoff be- tween the minimum number of pulses in a burst and the frequency range.




Burst Carrier Frequency
:MEASure :FREQuency :BURSt?
[- [<expected value>[,<resolution>]] [,<(@«1|2|3|4»)>]]

Measures the carrier frequency of a burst. The burst duration must be less than 50% of the pulse repetition frequency (PRF).
How to measure bursts is described in detail in the Operators Manual.
The counter uses <expected value> and <resolution> to select a Measurement Time ([:SENSe]:ACQuisition:APERture), see page 8-92, and then sets the sync delay (:FREQuency:BURSt:SYNC:PERiod) to 1.5 * Measurement Time. See page 8-95.
Parameters:
<expected value> is the expected carrier frequency,
<resolution> is the required resolution, e.g., 1 gives 1Hz resolution.
<(@«1|2|3|4»)> is the measurement channel: (@1) means input A1
(@2) means input B1
(@3) means input C (RF input, option for CNT-90, standard for CNT-90XL) (@4) means input E (Rear panel arming input)

If you omit the channel, the instrument measures on input A (@1).
1 The prescaling factor for these channels can be set to 1 or 2 by means of the command :SENSe:FREQuency:PREScaler:STATe. See page 8-94.


Complies with standards:	SCPI 1992.0, confirmed.

:MEASure :FREQuency :POWer [:AC]?
[-(@3)]
Power C
Measures the power of the signal on input C in dBm or W. Use the command
:FREQ:POW:UNIT DBM|W to select measurement unit.
Parameters:
(@3) is the measurement channel number of the RF input C.
It is redundant in this case, as there is no other RF channel available.

:MEASure :FREQuency :PRF?
[- [<exp. val.>[,<res.>]][,<(@«1|2|3|4»)>]]
Pulse Repetition Frequency
Measures the PRF (Pulse Repetition Frequency) of a burst signal.The burst dura- tion must be less than 50% of the pulse repetition frequency (PRF).
It is better to set up the measurement with the [:SENS]:FUNC “:FREQ:PRF” command when measuring pulse repetition frequency. This command will allow you to set a suitable sync delay with the :FREQuency:BURSt:SYNC:PERiod command.
How to measure bursts is described in detail in the Operators Manual.
Parameters:  <exp. val.> is the expected PRF, <res.> is the required resolution.
<(@«1|2|3|4»)> is the measurement channel: (@1) means input A
(@2) means input B
(@3) means input C (RF-input option)
(@4) means input E (Rear panel arming input)

If you omit the channel, the instrument measures on input A (@1).
The <expected value> and <resolution> are used to calculate the Measurement Time ([:SENSe]:ACQuisition:APERture). The Sync. Delay is always 10 µs (default value)

:MEASure :FREQuency :RATio?
[- [<expected value> [,<resolution>]][,<(@«1|2|3»)>,<(@«1|2|3»)>]]
Frequency Ratio
Frequency ratio measurements between two inputs.
Example:
SEND→ :MEAS:FREQ:RAT? - (@1),(@3)
READ← 2.345625764333E+000
This example measures the ratio between input A and input C.
☞ The channel is expression data and must be within parentheses ( ).
Parameters:  <expected value> and <resolution> are ignored
<(@«1|2|3»)>,<(@«1|2|3»)> are the measurement channels: (@1) means input A
(@2) means input B
(@3) means input C (RF input option)
If you omit the channels, the instrument measures between input A and input B.




Complies with standards:	SCPI 1991.0, confirmed.

:MEASure [:VOLT] :NCYCles?
[- [(@1|@2|@3)]
Number of Cycles in Burst
If :FREQ:BURSt is active, this function measures the number of cycles in each burst.
Returned format:  <Numeric value (integer)>
Example:
SEND→ :MEAS:NCYC? (@3)
READ← 2356J
This example shows a measurement on the RF channel.
☞ The channel is expression data and must be within parentheses ( ).
<(@«1|2|3»)>,<(@«1|2|3»)> are the measurement channels: (@1) means input A
(@2) means input B
(@3) means input C (RF input option)

:MEASure «:PDUTycycle | :DCYCle»?
[- [<threshold>] [,(@«1|2»)]]
Positive duty cycle: Duty Factor
Traditional duty cycle measurement is performed. That is, the ratio between the on time and the off time of the input pulse is measured.
Parameters
<threshold> parameter sets the trigger levels in volts. If omitted, the auto trigger level is set to 50 percent of the signal.
(@«1|2») is the measurement channel: (@1) means input A
(@2) means input B

If you omit the channel, the instrument measures on input A (@1).
Example:
SEND→ MEAS:PDUT?
READ← +5.097555E-001
In this example, the duty cycle is 50.97%




Complies with standards:	SCPI 1991.0, confirmed.

:MEASure :NDUTycycle?
[- [<threshold>] [,(@«1|2»)]]
Negative duty cycle: Duty Factor
Traditional duty cycle measurement is performed. That is, the ratio between the on time and the off time of the input pulse is measured.
Parameters
<threshold> parameter sets the trigger levels in volts. If omitted, the auto trigger level is set to 50 percent of the signal.
(@«1|2») is the measurement channel: (@1) means input A
(@2) means input B

If you omit the channel, the instrument measures on input A (@1).
Example:
SEND→ MEAS:PDUT?
READ←  +5.097555E-001
In this example, the duty cycle is 50.97%




Positive Peak Voltage
:MEASure [:VOLT] :MAXimum?
[ - («@1|@2»)]

This command measures the positive peak voltage with the input DC coupled.
Parameters:
(«@1|@2») is the measurement channel (@1) means input A
(@2) means input B














Complies with standards:	SCPI 1991.0, confirmed.
:MEASure [:VOLT] :MINimum?
[ - («@1|@2»)]
Negative Peak Voltage
This command measures the negative peak voltage with the input DC coupled
Parameters:
(«@1|@2») is the measurement channel (@1) means input A
(@2) means input B














Complies with standards:	SCPI 1991.0, confirmed.

:MEASure [:VOLT] :PTPeak?
[- (@«1|2»)].
Peak-to-Peak Voltage
This command measures the peak-to-peak voltage on either main input channel.
Parameters:
(@«1|2») is the measurement channel (@1) means input A
(@2) means input B














Complies with standards:	SCPI 1991.0, confirmed.

:MEASure [:VOLT] :RATio?
[-(@1|@2),(@1|@2)]
Peak-to-Peak Voltage Ratio in dB
This command measures the peak-to-peak voltage ratio in dB between the se- lected channels.
Parameters:
(@«1|2») is the measurement channel (@1) means input A
(@2) means input B




Positive Slew Rate
:MEASure [:VOLT] :PSLEwrate?
[-(@1|@2)]

This command measures the positive slew rate in V/s on either main input channel.
Parameters:
(@«1|2») is the measurement channel (@1) means input A
(@2) means input B



















Negative Slew Rate
:MEASure [:VOLT] :NSLEwrate?
[-(@1|@2)]

This command measures the negative slew rate in V/s on either main input chan- nel.
Parameters:
(@«1|2») is the measurement channel (@1) means input A
(@2) means input B

:MEASure :PERiod?
[- [<expected value> [,<resolution>]][,<(@«1|2|3»)>]]
Period
A traditional period time measurement is performed on a single period. Measuring time set by the :ACQ:APER command does not affect the measurement.
The <expected value> and <resolution> are used to calculate the Measurement Time ([:SENSe]:ACQuisition:APERture).
Parameters:
<expected value> is the expected Period,
<resolution> is the required resolution,
<(@«1|2|3»)> is the measurement channel: (@1) means input A
(@2) means input B
(@3) means input C (RF input option)

If you omit the channel, the instrument measures on input A (@1).




Complies with standards:	SCPI 1991.0, confirmed.

:MEASure :PERiod :AVERage?
[- [<expected value> [,<resolution>]][,<(@«1|2|3»)>]]
Period
A traditional period time measurement is performed on multiple periods. Measuring time set by the :ACQ:APER command determines the resolution.
The <expected value> and <resolution> are used to calculate the Measurement Time ([:SENSe]:ACQuisition:APERture).
Parameters:
<expected value> is the expected Period,
<resolution> is the required resolution,
<(@«1|2|3»)> is the measurement channel: (@1) means input A
(@2) means input B
(@3) means input C (RF input option)

If you omit the channel, the instrument measures on input A (@1).




Complies with standards:	SCPI 1991.0, confirmed.




Phase
:MEASure :PHASe?
[- [<expected value>[,<resolution>]] [,(@«1|2»),(@«1|2»)]]

A traditional PHASe measurement is performed.
Parameters:
<expected value> and <resolution> are ignored by the counter
The first (@«1|2») is the start channel and the second (@«1|2») is the stop channel (@1) means input A
(@2) means input B

If you omit the channel, the instrument measures between input A and input B.










Complies with standards:	SCPI 1991-0, approved.

:MEASure «:RISE :TIME | :RTIM»?
[- [<lower threshold> [,<upper threshold>[,<expected value>[,<resolution>]]]] [,(@1|@2)]
Rise Time
The transition time from 10% to 90% of the signal amplitude is measured.The mea- surement is always a single measurement and the Auto-trigger is always on, set- ting the trigger levels to 10% and 90 % of the amplitude. If you need an average transition time measurement or other trigger levels, use the :SENSe subsystem and manually set trigger levels instead.
Parameters:
<lower threshold>, <upper threshold>, <expected value> and <resolution are all ignored by the counter
<(@1)>or<(@2) is the measurement channel, i.e., input A or input B.










Complies with standards:	SCPI 1991.0, confirmed.

:MEASure «:FALL :TIME | :FTIM»?
[- [<lower threshold> [,<upper threshold>[,<expected value>[,<resolution>]]]]
[,(@1|@2)]]
Fall Time
The transition time from 90% to 10% of the signal amplitude is measured.
The measurement is always a single measurement and the Auto-trigger is always on, setting the trigger levels to 90% and 10 % of the amplitude. If you need an av- erage transition time measurement, or other trigger levels, use the :SENSe sub- system and manually set trigger levels instead.
Parameters:
<lower threshold>, <upper threshold>, <expected value> and <resolution> are all ignored by the counter
<(@1)> or <(@2)> is the measurement channel, i.e. input A or input B.








Complies with standards:	SCPI 1991.0, confirmed.

:MEASure :TINTerval?
- (@«1|2»),(@«1|2»)]
Time Interval
Traditional time-interval measurements are performed. The trigger levels are set automatically, and positive slope is used. The first channel in the channel list is the start channel, and the second is the stop channel.
Parameters:
The first (@«1|2|4») is the start channel and the second (@«1|2|4») is the stop channel (@1) means input A
(@2) means input B

If you omit the channel, input A is the start channel, and input B is the stop chan- nel.

:MEASure :PWIDth?
[- [<threshold>] [,<(@«1|2»)>]]
Positive Pulse Width
A positive pulse width measurement is performed.
This is always a single measurement. If you need an average pulse width mea- surement, use the :SENSe subsystem instead.
Parameters
<threshold> parameter sets the trigger levels in volts. If omitted, the auto trigger level is set to 50 percent of the signal.
<(@«1|2»)> is the measurement channel: (@1) means input A
(@2) means input B

If you omit the channel, the instrument measures on input A.






Complies with standards:	SCPI 1991.0, confirmed.


Negative Pulse Width

:MEASure :NWIDth?
[- [<threshold>] [,<(@«1|2»)>]]

A negative pulse width measurement is performed.
This is always a single measurement. If you need an average pulse width mea- surement, use the :SENSe subsystem instead.
Parameters
<threshold> parameter sets the trigger levels in volts. If omitted, the auto trigger level is set to 50 percent of the signal.
<(@«1|2»)> is the measurement channel: (@1) means input A
(@2) means input B

If you omit the channel, the instrument measures on input A.






Complies with standards:	SCPI 1991.0, confirmed.

:MEASure :ARRay :STSTamp?
-(<array size>)[,(@1)|(@2)]
Single Time Stamp
A time stamp (TS) is taken of the trigger level crossing on the selected input chan- nel. The commands :MEAS and :CONF automatically invoke :FORM:TINF ON to get the time stamp data, but when :FUNC is used instead, you should normally let it be preceded by the :FORMat:TINFormation ON command explicitly. Otherwise the TS1 values will be omitted. See Returned format below.
The deadtime to the next TS is due to pacing and interpolator calibration and can go down to 4 µs. The X counter records the number of trigger level crossings.
Depending on the state of the command :FORMat:TINFormation, one or two val- ues are output for each TS. If OFF, only the content of the X counter at the timestamp is output. If ON, both the X counter and the TS value are read and out- put as two values, separated by a comma in ASCII and REAL mode.
Parameters
Array size is the number of TS. One TS can contain 1or 2 numeric values depend- ing on the state of the :FORM:TINF command.
Returned Format:
<number of trg lvl crossings>,(<TS for trg lvl crossing>,)...deadtime...<number of trg lvl crossings>,(<TS for trg lvl crossing>,)...deadtime...etc.
The format is set by the :FORMat command, and the data in parentheses is sent if
:FORM:TINF ON is active.
1TS is the time stamp value in seconds since a certain start event that is not avail- able for external control. Consequently the TS values can only be used for relative time measurements.




Time Stamp
:MEASure :ARRay :TSTAmp?
-(<array size>)[,(@1)|(@2)]

Time stamps are taken of all positive and negative trigger level crossings of the se- lected input channel. The commands :MEAS and :CONF automatically invoke
:FORMat:TINFormation ON to get the time stamp data, but when :FUNC is used instead, you should normally let it be preceded by the :FORMat:TINFormation ON command explicitly. Otherwise the TS1 values will be omitted. See Returned format below.
Measurements are performed in groups of four TS results, two positive and two negative, with no deadtime between the values. Deadtime between groups is af- fected by pacing and interpolator calibration, down to 4 µs.
Measurement results of 0 indicate negative trigger level crossings, whereas posi- tive values indicate the number of positive trigger level crossings since the last re- set.
Parameters:
<array size> sets the number of samples. One complete group requires an array size of 4. It can contain 4 or 8 numeric values depending on whether :FOR- Mat:TINFormation is OFF or ON. See the first paragraph above.
Returned format:
<zero result>,<TS for neg. crossing>,<number of pos. crossings>,<TS for pos. crossing>,<zero result>,<TS for neg. crossing>,<number of pos. crossings>,<TS for pos. crossing>...deadtime...<zero result>,<TS for neg. crossing>... etc.

1TS is the time stamp value in seconds since a certain start event that is not avail- able for external control. Consequently the TS values can only be used for relative time measurements.

:MEASure: ARRay: FREQuency: BTBack?
-(<array size>)[,(@1)|(@2)]
Frequency Back-to-Back
This is the inverse function of Period Back-to-Back. See below. In STATISTICS mode measurement time is used for pacing the time stamps. The pacing parameter is not used in this case. Thus a series of consecutive frequency average measure- ments without dead time can be made in order to fulfil the requirements for correct calculation of Allan variance or deviation.
Parameters
<array size> sets the number of samples. (@1)|(@2) is the measurement channel:
(@1) means input A (@2) means input B









:MEASure: ARRay: PERiod: BTBack?
-(<array size>)[,(@1)|(@2)]
Single Period Back-to-Back
Every positive or negative zero crossing (depending on the selected slope) up to the maximum frequency (125 kHz with interpolator calibration ON or 250 kHz with interpolator calibration OFF) is time-stamped. For every new time stamp the previ- ous value is subtracted from the current value, and the result is stored.
In STATISTICS mode the array contains all periods up to the maximum input fre- quency (see above). For higher frequencies the average period time during the 4 or 8 µs observation time is stored. So, for higher frequencies the actual function is rather Period Average Back-to-Back.
The main purpose of this function is to make continuous measurements of rela- tively long period times without losing single periods due to result processing. A typical example is the 1-pps timebase output from GPS receivers.
Parameters
<array size> sets the number of samples. (@1)|(@2) is the measurement channel:
(@1) means input A (@2) means input B




Time Interval Error (TIE)
:MEASure: ARRay: TIError?
- (array size)[,[<exp value>[,<resol>],][(@1|(@2)]]

This command automatically performs TIE measurements on clock signals from a predefined collection of system frequencies. See list on page 8-100.
TIE is defined as positive and increasing if the measured frequency exceeds the reference frequency.






















This page is intentionally left blank.


Memory Subsystem





:MEMory
:DATA









:DELete



:RECord



:COUNt? - [<Dataset Number>]
:DELete - <Dataset Number>
:FETCh? - <Dataset Number>
:ARRay? - <Dataset Number>,<Number of Samples>|MAX
:STARt - <Dataset Number>
:NAME? - [<Dataset Number>]
:SAVE - <Dataset Number>[,<Label>]
:SETTings? - <Dataset Number>

:MACRo - ‘<Macro name>’
:FREE	:MACRo?
:NSTates?





Related Common Commands:
*DMC
*EMC
*GMC?
*LMC?
*LRN?
*PMC
*RCL
*RMC
*SAV












8-77 Command Reference

:MEMory :DATA :RECord :COUNt?
- [<Dataset Number>]
Number of Samples in Dataset
If the optional <Dataset Number> parameter is specified, the command returns the number of samples in the corresponding FLASH memory position 0-7.
If no parameter is specified, a comma-separated list is returned, containing the number of samples in each of the eight FLASH memory positions 0-7.















:MEMory :DATA :RECord :DELete
- <Dataset Number>
Erase Dataset
The command erases the measurement data array in the FLASH memory position with the number (0-7) given in the command parameter <Dataset Number>.




Fetch Sample in Dataset
:MEMory :DATA :RECord :FETCh?
- <Dataset Number>

The command fetches one sample from the FLASH memory position with the num- ber (0-7) given in the command parameter <Dataset Number>.
Set the start position with the command :MEMory:DATA:RECord:FETCh:STARt.



















- <Dataset Number>,<Number of Samples>|MAXimum
Fetch Array of Samples in Dataset
The command fetches an array of samples from the FLASH memory position with the number (0-7) given in the command parameter <Dataset Number>.
You can either specify the number of samples to be fetched or get all samples (up to 32000) by using the MAXimum parameter.

:MEMory :DATA :RECord :FETCh :STARt
- <Dataset Number>
Set Start Position for Dataset Fetch
The data pointer is set to the first sample in the Dataset entered as a number (0-7) in the command parameter <Dataset Number>.

















:MEMory :DATA :RECord :NAME?
- [<Dataset Number>]
Get Name of Dataset
If the optional <Dataset Number> parameter is specified, the command returns the name assigned to the Dataset.
If no parameter is given, the command returns a comma-separated list of all Dataset Names.

:MEMory :DATA :RECord :SAVE
- <Dataset Number>[,<Label>]
Save Measurement Data Array to Internal FLASH Memory
One of the eight (0-7) memory positions must be entered, but you can also enter an optional name (max 6 characters) for easier recognition.
A default name will be assigned automatically if you omit the <Label> parameter. It represents the abbreviated measurement function and the channel. For example: Period Single A will read PerA.
If the instrument is not in Hold when this command is sent, then Execution Error
(-200) will be placed in the error queue.
If the instrument is not in Statistics Mode when this command is sent, then Settings Conflict Error (-221) will be placed in the error queue.
If specified <Dataset> already contains data, then Directory Full Error (-255) will be placed in the error queue.
If there are more than 32000 samples to save, only the last 32000 will be saved without notification to the operator.





:MEMory :DATA :RECord :SETTings?
- <Dataset Number>
Recall Instrument Settings Used for Specified Dataset
The command returns the instrument settings used when the specified <Dataset> was saved. The format is the same as for :SYSTem:SET.

:MEMory :DELete :MACRo
- ‘<Macro name>’
Delete one Macro
This command removes an individual MACRo1.
Parameters
‘<Macro name>’ is the name of the macro you want to delete.
☞ <Macro name> is String data that must be surrounded by quotation marks.
See also:
*PMC, if you want to delete all macros.
1 The IEEE488.2 command *RMC (Remove Macro command) will also work. It performs exactly the same action as :MEMory:DELete:MACRo.








:MEMory :FREE :MACRo?
Memory Free for Macros
This command gives information of the free memory available for MACRos in the counter. If no macros are specified, 1160 bytes are available.
Returned format:
<Bytes available>, <Bytes used>J

















Complies with standards:	SCPI 1991.0, confirmed.

:MEMory :NSTates?
Memory States
The Number of States query (only) requests the number of *SAV/ RCL instrument setting memory states available in the counter. The counter responds with a value that is one greater than the maximum that can be sent as a parameter to the *SAV and *RCL commands. (States are numbered from 0 to max–1.)
Returned format:
<the number of states available>J














Complies with standards:	SCPI 1991.0, confirmed






















This page is intentionally left blank.


Output Subsystem

Control the pulse output (CNT-91 only)




:OUTPut
:POLarity	- NORMal | INVerted *
:TYPE	- PULSe | GATE | ALARm | OFF

* Only for ALARM, “high” is NORMAL

☞ See SOURCE Subsystem on page 8-103 for time parameter setting commands.

:OUTPut :POLarity
- NORMal | INVerted
Output Polarity
The command controls the polarity of the pulse output, but only if it is configured as an alarm circuit. See also the command :OUTPut:TYPE.
Parameters
NORMal means that the output level is high when the alarm has been activated.
INVerted means that the output level is low when the alarm has been activated. The output amplitude is fixed at TTL levels in 50 Ω.












:OUTPut :TYPE
- PULSe | GATE | ALARm | OFF
Output Configuration
The command controls the rear panel pulse output configuration.
Parameters
PULSe means that the output serves as a fixed TTL level pulse generator.
Note: See SOURCE Subsystem on page 8-103 for time parameter setting com- mands.
GATE (low level) means that the output signals a pending measurement.
ALARm (low or high level) means that the output indicates an alarm condition. Note: See command :OUTPut:POLarity to change the active polarity.
OFF (low level) means no activity.


Read Function



Perform Measurement and Read Data



:READ
[:SCALar]?
:ARRay? - <Array Size>|MAX

:READ?
Read one Result
The read function performs new measurements and reads out a measuring result without reprogramming the counter. Using the :READ? query in conjunction with the :CONFigure command gives you a measure capability where you can fine tune the measurement.
If the counter is set up to do an array of measurements, :READ? makes all the measurements in the array, stores the results in the output buffer, and fetches the first measuring result. Use FETCh? to fetch other measuring results from the out- put buffer. The :READ? query is identical to :ABORt;:INITiate;:FETCh?
Returned format:  <data>J
The format of the returned data is determined by the format commands :FORMat
and FORMat:FIXed.
Example:
SEND→ :CONF:FREQ;:INP:FILT - ON;:READ?
This example configures the counter to make a standard frequency measurement with the 100 kHz filter on. The counter is triggered, and data from the measure- ment are read out with the :READ? query.
SEND→ :READ?
This makes a new measurement and fetches the result without changing the pro- gramming of the counter.
Type of command: Aborts all previous measurement commands if *WAI is not used. See page 8-142.























Complies with standards:	SCPI 1991.0, confirmed.




Read an array of results
:READ :ARRay?
- «<array size for FETCh>|MAX»

The :READ:ARRay? query differs from the :READ? query by reading out several results at once after making the number of measurements previously set up by
:CONFigure:ARRay - or - :MEASure:ARRAy?.
The :READ:ARRay? query is identical to:
:ABORt;:INITiate;:FETCh:ARRay?_<array size for FETCh>
The <array size for FETCh> does not tell :READ to make that many measure- ments, only to fetch that many results. :CONF:ARR, - :MEAS:ARR,
:ARM:LAY1:COUN or :TRIG:LAY1:COUN sets the number of measurements.
Parameters:
<array size for FETCh> sets the number of measurement results in the array. The size must be equal to or less than the number of measurements in the output buffer. The maximum limit is 10000 due to the physical size of the output buffer.
MAX means that all the results in the output buffer will be fetched.
Returned format:  <data>[,<data>]J
The format of the returned data is determined by the format commands :FORMat
and :FORMat:FIXed.
SEND→ :ARM:COUN - 10;:READ:ARR? - 5
This example configures the counter to make an array of 10 standard measure- ments. The counter is triggered and data from the first five measurements are read out with the :READ? query.
Type of command:  Aborts all previous measurement commands if *WAI is not used.

You cannot combine Statistics with array readouts, so if you want to store and fetch individual values in a block measurement, you have to make sure the de- fault command :CALC:AVER:STATE OFF is active.
















Complies with standards:	SCPI 1991.0, confirmed.






















This page is intentionally left blank.


Sense Command Subsystem

Sense Subsystem Command Tree



[:SENSe]
:ACQuisition
:APERture	- <meas time> | MIN | MAX
:HOFF
[:STATe]	- ON | OFF
:MODE	- TIME
:TIME	- <numeric value> | MIN | MAX
:AUTO	- ONCE
:FREQuency
:BURSt
:APERture	- <numeric value> | MIN | MAX
:STARt
:DELay	- <numeric value> | MIN | MAX
:SYNC
:PERiod	- <numeric value> | MIN | MAX
:PREScaler
[:STATe]	- ON | OFF
:POWer
:UNIT *	- DBM | W
:RANGe
:LOWer	- <Miinimum frequency for autotrigger> | MIN | MAX
:REGRession	- ON | OFF | AUTO
:FUNCtion	- ‘Measuring function [ Primary channel [ , Secondary channel ] ]
:HF
:ACQuisition
[:STATe] *	- <boolean>
:FREQuency
:CENTer *	- <numeric value>
:ROSCillator
:SOURce	- INTernal | EXTernal
:TIError
:FREQuency	- <numeric value>
:AUTO	- ON | OFF
:TINTerval
:AUTO	- ON | OFF
:TOTalize
:GATE
[:STATe]	- ON | OFF
* CNT-90XL only

:ACQuisition :APERture
- «<Decimal value > | MIN | MAX»
Set the Measurement Time
Sets the gate time for one measurement.
Parameters:  <decimal value> is 20 ns to 1000 s.
MIN gives 20 ns and MAX gives 1000 s.
Returned format:  <Decimal value >J
*RST condition:	10 ms
SYST:PRESet condition:  200 ms












:ACQuisition :HOFF
<boolean>
Hold Off On/Off
Switches the Hold Off function On/Off.
Parameters:
<Boolean> = 1 / ON | 0 / OFF


Returned format:  1 | 0J
*RST condition:	OFF




Hold Off Time
Sets the Hold Off time value.
:ACQuisition :HOFF :TIME
- «<Decimal value> | MIN | MAX»

Parameters:
<Decimal data> = a number between 20E–9 and 2.0
Returned format:
<Decimal value>J


*RST condition:
200 µs















Autoset from the Bus
Performs the same task as the front panel button AUTO SET.
Parameters:
ONCE corresponds to pressing AUTO SET once. PRESet corresponds to double-clicking AUTO SET.
:AUTO
- ONCE | PRESet

:FREQuency :BURSt :APERture
«<Numeric value>|MIN|MAX»
Burst Measuring Time
Sets the time length within a burst during which the burst frequency is measured.
Parameters:  <Numeric value> = a number between 20 ns and 2 s.
Returned format:  <Numeric value>J
*RST condition:  200 µs














:FREQuency :BURSt :PREScaler [:STATe]
<Boolean>
Prescaler ÷2 on Input A & Input B
The burst frequency limit is 300 MHz if the prescaler is ON and 160 MHz if it is OFF.
Parameters:  <Boolean> = (1/ON | 0/OFF)

Returned format:  1 | 0J
*RST condition:	ON




Burst Start Delay
:FREQuency :BURSt :STARt :DELay
- «<Numeric value>|MIN|MAX»

Sets the burst start delay, i.e. the time length between the burst start and the actual start of the burst measuring time. This parameter is used for controlling the point of time when a measurement sample is taken.
Parameters:  <Numeric value> = a number between 20 ns and 2 s.
Returned format:  <Numeric value>J
*RST condition:  200 µs

















Burst Sync Delay
:FREQuency :BURSt :SYNC :PERiod
- «<Numeric value>|MIN|MAX»

Sets the synchronization delay time used in burst measurements. A correct value should be longer than the burst time and shorter than 1/PRF, i.e. the inverse of the pulse repetition frequency.
Parameters:  <Numeric value> = a number between 1*10-6 and 2 s.
Returned format:  <Numeric value>J
*RST condition:	400 µs

:FREQuency :POWer :UNIT
DBM|W
Input C Measurement Unit
Selects dBm or W as the basic measurement unit to be displayed or read out.
Parameters:  DBM | W
The reference level 0 dBm is 1 mW in 50 Ω. Increasing the level by 3 dB means doubling the power. Decreasing the level by 3 dB means halving the power.
Returned format: DBM | W J
*RST condition:	DBM












:FREQuency :RANGe :LOWer
«<Numeric value>|MIN|MAX»
High Speed Voltage Measurements
Use this command to speed up voltage measurements and Autotrigger functions when you don’t need to measure on low frequencies.

Parameters:
<Numeric value> between 1 and 50000 (Hz) MIN gives 1 Hz
MAX gives 50 kHz
Returned format:  <Numeric value>J
*RST condition:	100 (Hz)




Complies with standards:	SCPI 1991.0, confirmed.




Smart Frequency
:FREQuency :REGRession
- ON|OFF|AUTO

Despite its name, this command also applies to Period Average.
By means of continuous time stamping and linear regression analysis, the resolu- tion compared to a “normal” reciprocal counter is improved by one or two digits for measuring times between 200 ms and 100 s.
Not all combinatons of settings will work:
In local mode (front panel control), this function may be overridden by the firmware: Measurement time < 16 us: On is changed to Auto(Off)
Measurement time > 2.5 s: Off is changed to Auto(On) External arming: On is changed to Auto(Off)
An info box pops up explaining this.
In remote mode (bus control), no consistency checks are made until you try to is- sue an INITiate command. If, at that time, the settings are inconsistent, you get a "Settings conflict" error, and the measurement will not start.
*RST condition:	AUTO



:FUNCtion
- ‘<Measuring function>[_<Primary channel> [,<Secondary channel>]]’
Select Measuring Function
Selects which measuring function is to be performed and on which channel(s) the instrument should measure.
Parameters:
<Measuring function> is the function you want to select, according to the SENSe subsystem command trees on page 8-91.
<Primary channel> is the channel used in all single-channel measurements and the main channel in dual-channel measurements.
<Secondary channel> is the ‘other’ channel in dual-channel measurements. Only the primary channel may be programmed for all single channel measurements.
The measuring function and the channels together form one <String> that must be placed within quotation marks.
Returned format: “<Measuring function>_<Primary channel>[,<Secondary channel>]”J
Example Select a pulse period measurement on input A (channel 1): Send → :FUNC - ‘PER - 1’
*RST condition:	FREQuency_1


Complies with standards:	SCPI 1991.0, confirmed.





Input Channels
means input A
means input B
means input C (RF input option)
means input E (rear panel arming input)
6	means the internal reference




Input C Acquisition ON/OFF
:HF :ACQuisition [:STATe]
- <Boolean>

Switches the automatic acquisition system ON or OFF. ON means Automatic Ac- quisition, OFF means Manual Acquisition. When the instrument is switched from remote to local operation, Automatic Acquisition mode is entered, irrespective of the previous remote setting.
Parameters:
<Boolean> = «1 | ON» | «0 | OFF»
Returned format:	1 | 0 J
*RST condition:  ON
















Center Frequency
:HF :FREQuency :CENTer
- <Numeric value>

Sets the center frequency value for the RF input and is used when Manual Acquisi- tion has been selected.
Parameters: <Numeric value> = a number between 3*108 (Hz) and 27*109, 40*109, 46*109 or 60*109 (Hz), depending on the model number -27G, -40G, -46G or -60G respectively.
Returned format:  <Numeric value>J
*RST condition:	300 MHz

:ROSCillator :SOURce
- «INT|EXT|AUTO»
Select Reference Oscillator
Selects the signal from the external reference input as timebase instead of the in- ternal timebase oscillator. If the parameter is set to the default value AUTO, external reference will be used, if present.
Returned format:  <INT|EXT|AUTO>J
*RST condition:	AUTO



















Complies with standards:	SCPI 1991.0, confirmed.
:TIError :FREQuency :AUTO
«ON|OFF»
Automatic Recognition of Basic Frequency for TIE Measurement
If AUTO is ON, a check measurement is made at the start of the block to deter- mine if the frequency of the input signal, rounded to 4 significant digits, is listed for automatic recognition, for instance:
4, 8, 15.75, 64 kHz or
1.544, 2.048, 5, 10, 27, 34, 45, 52 MHz
If the command is successful, the found value will be stored and can be recalled with a query command. Subsequent TIE measurements will use this value until it is changed by sending this command once more or by sending the setting command
:TIError:FREQuency - <Numeric value>, which will deliberately fix the fre- quency.
Returned format:  1 | 0J
*RST condition:  OFFJ




Set Basic TIE Frequency
:TIError :FREQuency
- <Numeric value>

An arbitrary frequency in the range 1 Hz to 100 MHz can be entered (increment = 1 Hz). Subsequent TIE measurements are made by continuous timestamping of the input signal and the internal/external timebase clock. Observations of Wander, for instance, can easily be made by means of this command and the function
:MEASure:ARRay:TIError? in conjunction with the built-in statistics/graphics fa- cilities.
Parameter:  <Numeric value> = a number between 1 and 100*106 Hz in 1 Hz increments.


















Smart Time Interval
:TINTerval :AUTO
- «Boolean»

By means of 4 time stamps (2 on each channel), the counter can determine which event precedes the other. Thus you don’t have to set aside Input A as the start channel.

:TOTalize :GATE
ON | OFF
Control the GATE in Totalize Manual Mode
Open/closes the gate for :CONFigure:TOTalize[:CONTinuous].
Before opening the gate with this command, the counter must be in the ‘contin- uously initiated’ state (:INIT:CONT - ON), or else the totalizing will not start.
Parameters:  <Boolean> = (1 / ON | 0 / OFF)
Returned format:  <Boolean>J
Example:
Send → :CONF:TOT - (@1),(@2) // Select totalizing on inputs A & B and reset registers
Send → :INIT:CONT - ON;TOT:GATE - ON // Initiate totalizing Read ← :FETCh:ARRay? - -1 // Read intermediate results (A & B) Send → TOT:GATE - OFF // Stop totalizing
Send → TOT:GATE - ON // Start totalizing and accumulate results Send → TOT:GATE - OFF // Stop totalizing
Read ← :FETCh:ARRay? - -1 // Read final results (separated by a comma)
*RST condition:	OFF


Source Subsystem



Set Time Parameters for Pulse Output (CNT-91 only)




:SOURce
:PULSe
:PERiod - <Numeric value>
:WIDTh - <Numeric value>

:SOURce :PULSe :PERiod
<Numeric value>
Set Pulse Period
The pulse generator time parameters are activated when the output type is config- ured to PULSe using the :OUTPut command. See page 8-85.
Parameter:  <Numeric value> = a number between 20*10-9 and 2 s in 10 ns increments.
















:SOURce :PULSe :WIDTh
<Numeric value>
Set Pulse Width
The pulse generator time parameters are activated when the output type is config- ured to PULSe using the :OUTPut command. See page 8-85.
Parameter:  <Numeric value> = a number between 10*10-9 and <2 s in 10 ns increments.


Status Subsystem






:STATus
:DREGister0


:OPERation


:ENABle	- <bit mask>
[:EVENt]?

:CONDition?
:ENABle	- <bit mask>
[:EVENt]?

:QUEStionable
:CONDition?
:ENABle	- <bit mask>
[:EVENt]?
:PRESet

Related Common Commands:
*CLS
*ESE	- <bit mask>
*ESR?
*PSC	- <bit mask>
*SRE	- <bit mask>
*STB?

:STATus :DREGister0?
Read Device Status Event Register
This query reads out the contents of the Device Event Register. Reading the De- vice Event Register clears the register. See Figure 6-10.
Returned format:
<dec.data> = the sum (between 0 and 6) of all bits that are true. See table below:


1FW checks the oscillator status approximately once every 10 to 20 ms, sometimes less frequently depending on the CPU interrupt priority handling, and sets or clears these bits. The operator can utilize these bits in the same way as other status bits,
i.e. wait for event, read status etc.

:STATus :DREGister0 :ENABle
<bit mask>
Enable Device Status Reporting
This command sets the enable bit of the Device Register 0.
Parameters:
<dec.data> = the sum (between 0 and 6) of all bits that are true. See table below:


Returned format:  <bit mask>J

Read Operation Status Condition Register
Reads out the contents of the operation status condition register. This register re- flects the state of the measurement process. See table below.
Returned Format:
<Decimal data> = the sum (between 0 and 368) of all bits that are true. See table below:

Complies with standards:	SCPI 1991.0, confirmed.

:STATus :OPERation :ENABle
<Decimal data>
Enable Operation Status Reporting
Sets the enable bits of the operation status enable register. This enable register contains a mask value for the bits to be enabled in the operation status event reg- ister. A bit that is set true in the enable register enables the corresponding bit in the status register. See figure on page 8-107.
An enabled bit will set bit #7, OPR (Operation Status Bit), in the Status Byte Regis- ter if the enabled event occurs. See also status reporting on page 3-10.
Power-on will clear this register if power-on clearing is enabled via *PSC.
Parameters: <dec.data> = the sum (between 0 and 368) of all bits that are true. See ta- ble below:
Returned Format:  <Decimal data>J
Example:
SEND→ :STAT:OPER:ENAB - 288
In this example, waiting for triggering, bit 5, and Measurement stopped, bit 8, will set the OPR-bit of the Status Byte. (This method is faster than using *OPC if you want to know when the measurement is ready.)



















Complies with standards:	SCPI 1991.0, confirmed.

Read Operation Status, Event
Reads out the contents of the operation event status register. Reading the Opera- tion Event Register clears the register. See figure on page 8-107.
Returned Format:  <Decimal data>J
<dec.data> = the sum (between 0 and 368) of all bits that are true. See table on page 8-108.















Complies with standards:	SCPI 1991.0, confirmed.


:STATus :PRESet

Enable Device Status Reporting
This command has an SCPI standardized effect on the status data structures. The purpose is to precondition these toward reporting only device-dependent status data.
It only affects enable registers. It does not change event and condition registers.
The IEEE-488.2 enable registers, which are handled with the common commands *SRE and
*ESE remain unchanged.
The command sets or clears all other enable registers. Those relevant for this counter are as follows:
It sets all bits of the Device status Enable Registers to 1.
It sets all bits of the Questionable Data Status Enable Registers and the Operation Status En- able Registers to 0.
The following registers never change in the counter, but they do conform to the standard
:STATus:PRESet values.
All bits in the positive transition filters of Questionable Data and Operation status registers are 1.
All bits in the negative transition filters of Questionable Data and Operation status registers are 0.

:STATus :QUEStionable :CONDition?
Read Questionable Data/Signal Condition Register
Reads out the contents of the status questionable condition register.
Returned Format:
<dec.data> = the sum (between 0 and 17920) of all bits that are true. See table below:

Complies with standards:	SCPI 1991.0, confirmed.


- <Decimal data>
Enable Questionable Data/Signal Status Reporting
Sets the enable bits of the status questionable enable register. This enable register contains a mask value for the bits to be enabled in the status questionable event register. A bit that is set true in the enable register enables the corresponding bit in the status register. See figure on page 8-110.
An enabled bit will set bit #3, QUE (Questionable Status Bit), in the Status Byte Register if the enabled event occurs. See also status reporting on page 3-10.
Power-on will clear this register if power-on clearing is enabled via *PSC.
Parameters:
<dec.data> = the sum (between 0 and 17920) of all bits that are true. See the table on page 8-110.
Returned Format:  <Decimal data> J
Example:
Send →:STAT:QUES:ENAB - 16896
In this example, both ‘unexpected parameter’ bit 14, and ‘overflow’ bit 8, will set the QUE-bit of the Status Byte when a questionable status occurs.


Complies with standards:	SCPI 1991.0, confirmed.

:STATus :QUEStionable?
Read Questionable Data/Signal Event Register
Reads out the contents of the status questionable event register. Reading the Status Questionable Event Register clears the register. See figure on page 8-110.
Returned Format:
<dec.data> = the sum (between 0 and 17920) of all bits that are true. See the table on page 8-110.















Complies with standards:	SCPI 1991.0, confirmed.






















This page is intentionally left blank.


System Subsystem





:SYSTem
:COMMunicate
:GPIB

:ERRor?
:INSTrument
:TBASe



:ADDRess	- <Numeric value> | MIN | MAX


:LOCK?

:LANGuage	- NATive | COMPatible
:PRESet
:SET	- <Block data>
:TALKonly	- ON
:TEMPerature?
:TOUT
[:STATe]	- ON | OFF
:AUTO	- ON | OFF
:TIME	- <timeout value>
:UNPRotect


Related common commands:

*IDN?
*OPT?
*PUD - <arbitrary block program data>
*RST

:SYSTem :COMMunicate :GPIB :ADDRess
- «<Numeric value>|MAX|MIN» [,«<Numeric value>|MAX|MIN»]
Set GPIB Address
This command sets the GPIB address. It is valid until a new address is set, either by sending a new bus command or via the front panel USER OPT menu.
Parameters:
<Numeric value> is a number between 0 and 30. MIN sets address 0.
MAX sets address 30.
[,<Numeric value>|MAX|MIN] sets a secondary address. This is accepted but not used in the '9X'.
[:SELF] - This optional parameter is accepted by the '9X'.
Returned format:>  <Numeric value>J
Example:
SEND→ :SYST:COMM:GPIB:ADDR - 12
This example sets the bus address to 12.





Complies with standards:	SCPI 1991.0, confirmed.

:SYSTem :ERRor?
Queries for an ASCii text description of an error that occurred. The error messages are placed in an error queue, with a FIFO (First In-First Out) structure. This queue is summarized in the Error AVailable (EAV) bit in the status byte.
Returned format:
<error number>,"<Error Description String>"J
Where:
<Error Description String> = an error description as ASCii text.
See also:  Chapter 7, error messages.












Complies with standards:	SCPI 1991.0, confirmed.

:SYSTem: INSTRument: TBASe: LOCK?
Check Rubidium Oscillator Status
Query command returning the status of the rubidium oscillator control loop.
Returned format:>  <Numeric value>J

A “1” means “locked”
A “0” means “unlocked”.




















Select GPIB Mode
:SYSTem :LANGuage
- NATive | COMPatible

The user can select between two command sets, where native exploits the full capability of the instrument, and compatible facilitates portability to test systems using the Agilent counters 53131 and 53132.
The command set described in this manual refers to the native mode only.

:SYSTem :PRESet
Preset
This command recalls the same default settings that are entered when you press USER OPT → Save/Recall → Recall Setup → Default.
☞ These are not exactly the same settings as after *RST:
:SYST:PRES gives 200 ms Measurement Time
:SYST:PRES activates :INIT:CONT ON
*RST gives 10 ms Measurement Time
*RST activates :INIT:CONT OFF
See page 8-44.
See also:  Default settings after *RST on page 2-2.









Complies with standards:	SCPI 1991.0, confirmed.

:SYSTem :SET
- <Block data>
Read or Send Settings
Transmits in binary form the complete current state of the instrument. This data can be sent to the instrument to later restore this setting. This command has the same function as the *LRN? common command with the exception that it returns the data only as response to :SYST:SET?. The query form of this command re- turns a definite block data element.
Parameters:
<Block data> is the instrument setting previously retrieved via the :SYSTem:SET? query.
Returned format:  <Block data>J
Example:
SEND→ :SYST:SET?
READ← #41686<data byte 1><data byte 2>...<data byte 1686>
Note: The real number of data bytes will probably differ from the one specified above and depends on the counter type and the firmware version.




Complies with standards:	SCPI 1991.0, confirmed.




Enter Talk Only Mode
:SYSTem :TALKonly
- ON

The main purpose is to transfer streaming data fast in monitoring systems without predefined limits for time or number of samples. It is a non-reversible command,
i.e. you can only return to normal bus mode by sending IFC or pressing the CAN- CEL button on the front panel.
The Talk Only output buffer can hold one value. If a new measurement result is ready for output before the previous one has been transferred, the new value is rejected and the previous transfer is left undisturbed.
Consequently a pause during the reading will cause the first value read after the pause to be the first measurement finished after the latest pre-pause value was read. The second value read will be that of the most recently finished measure- ment. All values in between are lost. The same applies if there's a pause between turning on Talk Only and starting to read values. So, a dummy read is recommend- able in many cases.
Prerequisites
DISPlay:ENABle should be OFF. FORMat should be REAL or PACKed. ARM:COUNt and TRIGger:COUNt should both be one. INIT:CONTinuous should be ON.
Smart Period/Frequency/Time Interval or any functions using voltage measurement or timestamp can not be used with Talk Only.

:SYSTem :TEMPerature?
Read Temperature
This command returns the temperature in°C at the fan control sensor inside the in- strument housing.
Returned format:  <Numeric value>J
Example:
SEND→ :SYST:TEMP?
READ← 50

:SYSTem :TOUT
- <Boolean>
Timeout On/Off
This command switches the timeout on or off. When timeout is enabled, the mea- surement attempt will be abandoned when the time set with :SYST:TOUT:TIME has elapsed. Depending on GPIB mode and output format, a special response message will be sent to the controller instead of a measurement result, and the timeout bit in the STATus QUEStionable register will be set.
Returned format:  See table on page 8-36.
Example:
SEND→ :SYST:TOUT-1;TOUT:TIME-0.5;:STAT:QUES:ENAB-1024;:*SRE-8
This example turns on timeout, sets the timeout to 0.5 s, enables status reporting of questionable data at timeout, and enables service request on questionable data.
SEND→ *STB?	If bit 3 in the status byte is set, read the questionable data status.
SEND→ :STAT:QUES:EVEN?	This query reads the ques- tionable data status.
READ← «1024|0»	1024 means timeout has occurred, and 0 means no timeout.
*RST condition:  0


:SYSTem :TOUT :AUTO
- <Boolean>
Timeout, Automatic
This command is primarily intended for use with long measurement times to quickly determine if there is any signal at all present at the input, without having to wait for the entire measurement to time out.
If ON there will be a short timeout of 2 timer ticks (10-20ms) from the INIT/ARM to the first start trigger, independent of any other timeout setting.
*RST condition:	OFF.




Timeout, Set
:SYSTem :TOUT :TIME
- «<Numeric value>|MIN|MAX»

This command sets the timeout in seconds with a resolution of 10 ms.
The 10 ms timer ticks start to be counted after EITHER a measurement INIT (if Arming is not selected) OR an external arming event (if Arming is selected). The counting stops at the stop trigger of the measurement. For block measurements a timeout results in the whole block timing out. The measurement START is not in- volved. See also :SYST:TOUT:AUTO if you need a command dealing with unnec- essarily long timeouts due to absence of input signal.
Note that you must enable timeout using :SYST:TOUT_ON for this setting to take effect.
Parameters:
<Numeric value> is the timeout in seconds. The range is 0.01 to 1000 (s) MIN gives 0.01 s
MAX gives 1000 s
Returned format:  <Numeric value>J
*RST condition:  0.1 (s)


Complies with standards:	SCPI 1991.0, confirmed.


:SYSTem :UNPRotect

Unprotect
This command will unprotect the user data (set/read by *PUD) and front setting memories 1-10 until the next PMT (Program message terminator) or Device clear or Reset (*RST). This makes it necessary to send an unprotect command in the same message as for instance *PUD.
Example
Send → :SYST:UNPR; *PUD - #240Calibrated - 1992-11-17, - inven- tory No.1234


Where:
# means that <arbitrary block program data> will follow.
2 means that the two following digits will specify the length of the data block 40 is the number of characters in this example






















This page is intentionally left blank.


Test Subsystem







:TEST

:SELect	- RAM | ROM | LOGic | DISPlay | ALL


Related common command:

*TST

:TEST :SELect
- «RAM | ROM | LOGic | DISPlay| ALL»
Select Self-tests
Selects which internal self-tests shall be used when self-test is requested by the
*TST command.


Returned format:
«RAM | ROM | LOGic | DISPlay | ALL»J


*RST condition:	ALL


Trigger Subsystem



:TRIGger
[ :STARt | :SEQuence [ 1 ] ] [ :LAYer [ 1 ] ]
:COUNt - <Numeric value> | MIN | MAX
:SOURCE
:TIMER




Related common command:
*TRG

:TRIGger :COUNt
- «<Numeric value> | MIN | MAX»
No. of Triggerings on each Ext Arm start
Sets how many measurements the instrument should make for each ARM:STARt condition, (block arming).
These measurements are done without any additional arming conditions before the measurement. This also means that stop arming is disabled for the measurements inside a block.
The actual number of measurements made on each INIT equals to:
(:ARM:START:COUN)*(:TRIG:START:COUNT)
Parameters:
<Numeric value> is a number between 1 and 16777215 (224-1).
MAX gives 16777215
MIN gives 1
Example:
SEND→ :TRIG:COUN - 50
Returned format:  <Numeric value>J
*RST condition:  1


Complies with standards:	SCPI 1991.0, confirmed.

:TRIGger :SOURce
-TIMer | IMMediate
Pacing
Enables or disables the pacing function, i.e. the sample rate control. The pacing time is set by the :TRIG:TIM command.
Parameters:
TIMer - enables pacing IMMediate - disables pacing
*RST condition:  IMM




Set Pacing Time
:TRIGger: TIMer
-<Numeric value> | MIN | MAX

This command sets the sample rate, for instance in conjunction with the statistics functions.
Parameters:
<Numeric value> is a time length between 2 µs and 500 s, entered in seconds. MIN means 2 µs.
MAX means 500 s.
Returned format:  <Numeric value>J
*RST condition:  20 ms






















This page is intentionally left blank.


Common Commands

*CLS
*DDT	- <Arbitrary block program data>
*DMC	- <Macro label> , <Program messages>
*EMC	- <Decimal data>
*ESE	- <Decimal data>
*ESR?
*GMC?	- <Macro label>
*IDN?
*LMC?
*LRN?
*OPC
*OPC?
*OPT?
*PMC
*PSC	- <Decimal data>
*PUD	- <Arbitrary block program data>
*RCL	- <Decimal data>
*RMC	- <Macro name>
*RST
*SAV	- <Decimal data>
*SRE	- <Decimal data>
*STB?
*TRG
*TST?
*WAI

*CLS
Clear Status Command
The *CLS common command clears the status data structures by clearing all event registers and the error queue. It does not clear enable registers and transition fil- ters. It clears any pending *WAI, *OPC, and *OPC?.
Example:
Send →*CLS















Complies with standards:	IEEE 488.2 1987.

*DDT
-<arbitrary block>
Define Device Trigger
Sets or queries the command that the device will execute on receiving the GET in- terface message or the *TRG common command.
The currently supported DDTs are:
#14INIT	4. #15READ?
#19INIT;*OPC	5. #215ARM:LAY2;:FETC?
#15FETC?	6. #18ARM:LAY2


Example:
Send → *DDT-#19INIT;*OPC
*RST condition:
#215ARM:LAY2;:FETC? in native mode and #14INIT in compatible mode





Complies with standards:	IEEE 488.2 1987.




Define Macro
*DMC
- <Macro label> , <Program messages>

Allows you to assign a sequence of one or more program message units to a macro label. The sequence is executed when the macro label is received as a command or query. Twenty-five macros can be defined at the same time, and each macro can contain an average of 40 characters.
If a macro has the same name as a command, it masks out the real command with the same name when macros are enabled. If macros are disabled, the original command will be executed.
If you define macros when macro execution is disabled, the counter executes the
*DMC command fast, but if macros are enabled, the execution time for this com- mand is longer.
Parameters:
<Macro label> = 1 to 12-character macro label. (String data must be surrounded by “ ” or ‘ ‘ as in the example below.)
<Program messages> = the commands to be executed when the macro label is received, both block data and string data formats can be used.
Example 1:
SEND→ *DMC ‘FREQUENCY?’,":FUNC - ‘FREQ - 1’;:INP:LEV:AUTO - ON
;:ARM:START:LAY2:SOURCE - BUS;:INIT:CONT - ON;*TRG"
This example defines a macro called FREQUENCY?.
SEND→ FREQUENCY?
The macro makes a single frequency measurement with automatic trigger level setting and places the result in the output queue. (Macros must be enabled; other- wise, the :FREQUENCY? query will not execute, see ☛EMC)).
READ←+31.415926536E+006
Example 2:
SEND→ *DMC - ‘AUTOFILT’,":INP:LEV:AUTO - $1;:INP:FILT -
$1;:INP2:LEV:AUTO - $1;:INP2:FILT - $1"
This example defines a macro called AUTOFILT which takes one Boolean argu- ment, i.e. «ON|OFF» ($1) .
SEND→ AUTOFILT - OFF
Turns off both the auto function and the analog lowpass filter on both input channels.

*EMC
-<Decimal data>
Enable Macros
This command enables and disables expansion and execution of macros. If mac- ros are disabled, the instrument will not recognize a macro although it is defined in the instrument. (The Enable Macro command takes a long time to execute.)
Parameters:
<Decimal data> = is 0 or 1. A value which rounds to 0 turns off macro execution. Any other value turns macro execution on.
Note that 1 or 0 is <Decimal data>, not <Boolean>! ON|OFF is not allowed here!
Returned format:  «1|0» J
1 indicates that macro expansion is enabled. 0 indicates that macro expansion is disabled.
Example:
SEND→*EMC - 1
Enables macro expansion and execution.




Complies with standards:	IEEE 488.2 1987.




Standard Event Status Enable
*ESE
-<Decimal data>

Sets the enable bits of the standard event enable register. This enable register contains a mask value for the bits to be enabled in the standard event status regis- ter. A bit that is set true in the enable register enables the corresponding bit in the status register. An enabled bit will set the ESB (Event Status Bit) in the Status Byte Register if the enabled event occurs. See also status reporting on page 3-10.
Parameters:  <dec.data> = the sum (between 0 and 255) of all bits that are true.
Returned Format:  <Decimal data> J

Example:
SEND→ *ESE - 36
In this example, command error, bit 5, and query error, bit 2, will set the ESB-bit of the Status Byte if these errors occur.

Figure 8-3	Bits in the standard event status register.

ESR?
Event Status Register
Reads out the contents of the standard event status register. Reading the Standard Event Status Register clears the register.
Returned Format:
<dec.data> = the sum (between 0 and 255) of all bits that are true. See table on page 8-131.
















Complies with standards:	IEEE 488.2 1987.

*GMC?
- < macro label>
Get Macro Definition
This command makes the counter respond with the current definition of the given macro label.
Parameters:
<Macro label> = the label of the macro for which you want to see the definition. (String data must be surrounded by “ ” or ‘ ‘ as in the example below.)
Returned Format:  <Block data>J
Example:
SEND→ *GMC? - ‘AUTOTRGLVL?’
Gives a block data response, for instance:
READ←
#242:FUNC ‘FREQ 1’;:INP:LEV:AUTO ONCE;INP:LEV?







Complies with standards:	IEEE 488.2 1987.

*IDN?
Identification query
Reads out the manufacturer, model, serial number, and firmware level in an ASCii response data element. The query must be the last query in a program message.
Response is <Manufacturer> , <Model>1 , <Serial Number>, <Firmware Level>.
Example:
SEND →*IDN?
READ← <MANUFACTURER>, <MODEL>1, 1234567, V1.01 28 Jun 2004

Notes:
1The CNT-91R returns the same string as the standard CNT-91, i.e. “CNT-91”.










Complies with standards:	IEEE 488.2 1987.


*LMC?

Learn Macro
Makes the instrument send a list of string data elements, containing all macro la- bels defined in the instrument.
Returned Format:
<String> { ,<String> }J
<String> = a Macro label. (String data will be surrounded by “ ” as in the example below.)
Example:
SEND→ *LMC?
May give the following response: READ←“AUTOFILT”,"AMPLITUDE?"









Complies with standards:	IEEE 488.2 1987.

*LRN?
Learn Device Setup
Learn Device Setup Query. Causes a response message that can be sent to the in- strument to return it to the state it was in when the *LRN? query was made.
Returned Format:
:SYST:SET_<Block data>J
Where:
<Block data> is #3104<104 data bytes>


Example
SEND→ *LRN?









Complies with standards:	IEEE 488.2 1987.

*OPC
Operation Complete
The Operation Complete command causes the device to set the operation com- plete bit in the Standard Event Status Register when all pending selected device operations have been finished. See also Example 4 in Chapter 4.
Example:
Enable OPC-bit
SEND→ *ESE - 1
Start measurement (INIT). *OPC will set the operation complete bit in the status register when the measurement is done.
SEND→ :INIT;*OPC
Wait 1s for the measurement to stop. Read serial poll register, will reset service request
SPOLL
Check the Operation complete bit (0) in the serial poll byte. If it is true the measurement is completed and you can fetch the result.
SEND→ FETCh?
Then read the event status register to reset it:
SEND→ *ESR?
If bit 0 is false, abort the measurement.
SEND→ :ABORt
Complies with standards:	IEEE 488.2 1987.

*OPC?
Operation Complete Query
Operation Complete query. The Operation Complete query places an ASCii char- acter 1 into the device’s Output Queue when all pending selected device opera- tions have been finished.


Returned Format:  1J
See also:
Example 6 is Chapter 4.












Complies with standards:	IEEE 488.2 1987.


*OPT?

Option Identification
Response is a list of all detectable options present in the instrument, with absent options represented by an ASCii ‘0’.
Returned format:
<Timebase option>,<Prescaler option1|Microwave converter2>, <Reserved>J
Where:
<Timebase option> =  Standard3|Option 194|Option 304|Option 404|Rubidium5
<Prescaler option> = 0|Option 10|Option 13|Option 14|Option 14B
<Microwave converter> = 27GHz|40GHz|46GHz|60GHz
<Reserved> = 0 until further notice
Notes:
1CNT-90/91(R) only
2CNT-90XL only
3CNT-90/91 only
4CNT-90/91 & CNT-90XL
5CNT-91R only




Complies with standards:	IEEE 488.2 1987.

*PMC
Purge Macros
Removes all macro definitions.
Example: *PMC
See also:
:MEMory:DELete:MACRo - ‘<Macro-name>’ if you want to remove a single macro.















Complies with standards:	IEEE 488.2 1987.

*PSC
- <Decimal data>
Power-on Status Clear
Enables/disables automatic power-on clearing. The status registers listed below are cleared when the power-on status clear flag is 1. Power-on does not affect the registers when the flag is 0.
Service request enable register (*SRE)
Event status enable register (*ESE)
Operation status enable register (:STAT:OPER:ENAB)
Questionable data/signal enable register (:STAT:QUES:ENAB)
Device enable registers (:STAT:DREG0:ENAB)
*RST does not affect this power-on status clear flag.
Parameters: <Decimal data> = a number that rounds to 0 turns off automatic power-on clearing. Any other value turns it on.
Returned Format: «1 | 0» J
1 is enabled and 0 is disabled.
Example: *PSC - 1
This example enables automatic power-on clearing.
Complies with standards:	IEEE 488.2 1987.




Protected User Data
*PUD
- Arbitrary block program data>

Protected user data. This is a data area in which the user may write any data up to 64 characters. The data can always be read, but you can only write data after un- protecting the data area. A typical use would be to hold calibration information, us- age time, inventory control numbers, etc.
The content at delivery is: #234 FACTORY CALIBRATED ON: 19YY-MM-DD
YY = year, MM = month, DD = day
Returned format:  <Arbitrary block response data>J
Where:
<arbitrary block program data> is the data last programmed with *PUD.
Example
Send → :SYST:UNPR; *PUD - #240Calibrated - 1993-07-16, - inven- tory - No.1234
# means that <arbitrary block program data> will follow.
2 means that the two following digits will specify the length of the data block. 40 is the number of characters in this example.


Complies with standards:	IEEE 488.2 1987.


Recall

*RCL
-<Decimal data>

Recalls one of the up to 20 previously stored complete instrument settings from the internal nonvolatile memory of the instrument.
Memory number 0 contains the power-off settings.
Parameters:
<Decimal data> = a number between 0 and 19.
Example:
SEND→ *RCL - 10J












Complies with standards:	IEEE 488.2 1987.

RMC
- ‘<Macro name>’
Delete one Macro
This command removes an individual MACRo.
Parameters:
‘<Macro name>’ is the name of the macro you want to delete.

☞ <Macro name> is String data that must be surrounded by quotation marks.
See also:
*PMC, if you want to delete all macros.











*RST
Reset
The Reset command resets the counter. It is the third level of reset in a 3-level re- set strategy, and it primarily affects the counter functions, not the IEEE 488 bus.
The counter settings will be set to the default settings listed on page 2-2. All previ- ous commands are discarded, macros are disabled, and the counter is prepared to start new operations.
Example: *RST
See also:
Default settings on page 2-2.




Save
*SAV
_<Decimal data>

Saves the current settings of the instrument in an internal nonvolatile memory. Nineteen memory locations are available. Switching the power off and on does not change the settings stored in the registers.
Note that memory positions 1 to 10 can be protected from the front panel USER OPT menu. If this has been done, use the :SYSTem:UNPRotect command to al- ter these memory positions.
Parameters
<Decimal data> = a number between 1 and 19.
Example:
SEND→ *SAV - 11J









Complies with standards:	IEEE 488.2 1987

*SRE
- <Decimal data>
Service Request Enable
The Service Request Enable command sets the service request enable register bits. This enable register contains a mask value for the bits to be enabled in the status byte register. A bit that is set true in the enable register enables the corre- sponding bit in the status byte register to generate a Service Request.
Parameters:  <dec.data> = the sum (between 0 and 255) of all bits that are true.
See table below:

Returned Format:  <Integer>J
Where:
<Integer> = the sum of all bits that are set.
Example: *SRE - 16
In this example, the counter generates a service request when a message is avail- able in the output queue.

*STB?
Status Byte Query
Reads out the value of the Status Byte. Bit 6 reports the Master Summary Status bit (MSS), not the Request Service (RQS). The MSS is set if the instrument has one or more reasons for requesting service.
Returned Format:
<Integer> = the sum (between 0 and 255) of all bits that are true. See table below:
See also:  If you want to read the status byte with the RQS bit, use serial poll.
Complies with standards:	IEEE 488.2 1987.

*TRG
Trigger
The trigger command *TRG starts the measurement and places the result in the output queue.
It is the same as:
:ARM:STARt:LAYer2:IMM; *WAI;:FETCh?
The Trigger command is the device-specific equivalent of the IEEE 488.1 defined Group Execute Trigger, GET. It has exactly the same effect as a GET after it has been received, and parsed by the counter.
However, GET is much faster than *TRG, since GET is a hardware signal that does not have to be parsed by the counter.
Example:
SEND→ :ARM:START:LAY2:SOURCE - BUS
SEND→ :INIT:CONT - ON
SEND→ *TRG
READ← +3.2770536E+004
Type of Command:
Aborts all previous measurement commands if not *WAI is used.


Complies with standards:	IEEE 488.2 1987.

*TST?
Self Test

The self-test query causes an internal self-test and generates a response indicat- ing whether or not the device completed the self-test without any detected errors.
Returned Format:  <Integer>J
Where:
<Integer> = a number indicating errors according to the table below.



Complies with standards:	IEEE 488.2 1987

*WAI
Wait-to-continue
The Wait-to-Continue command prevents the device from executing any further commands or queries until execution of all previous commands or queries has been completed.
Example:
SEND→:MEAS:FREQ?; *WAI;:MEAS:PDUT?
In this example, *WAI makes the instrument perform both the frequency and the Duty Cycle measurement. Without *WAI, only the Duty Cycle measurement would be performed.
READ← +5.1204004E+002;+1.250030E-001





Chapter 9

Index

Index


!
1 Mohm	8-48
50 ohms	8-48
A
Abort
Measurement	8-4
AC|DC	8-46
Address
GPIB	8-114
Switches	1-4
Analog
Filter	8-47
Analog Filter	8-47
Aperture	8-92
Arbitrary block data	8-119
Arming	8-7
Bus arm mode	8-8
Start delay	8-7
Start slope	8-8
Start source	8-9
Stop slope	8-9
Stop source	8-10
Subsystem	8-5
Wait for bus	6-19
Array
Fetch	8-35
Asterisk	3-8
Attenuation	8-46
Auto
Attenuation	8-46
Levels selected by	8-50
Power on clearing	8-136
Speed	8-96
Trigger level	8-49
Trigger On/Off	8-49
Auto calibration on/off	8-26
Auto Freq. Recognition (TIE)	8-100
B
Block arming	8-124
Block data	3-12
Boolean	3-11
Burst
Carrier Frequency	8-61
Repetition Frequency	8-62
Bus
Drivers	1-6
Bus Arm	8-6
Exit	8-7
Mode	8-8
On/Off	8-8
Override	8-7
Bus initialization	3-19
C
Calculate
Block	5-3
Enable	8-22
Mathematics	8-21
Reading data	8-14
Subsystem	8-11

Calibration	· 8-119, 8-137
Subsystem	8-25
Center Frequency	8-99
Channel
List	3-12
Selecting · · · · · · · · · · · · · · · 6-9, 8-97 Character data	3-12
Check
Upper limit	8-21
Check Against Lower Limit	8-20
Clear Status	8-128
Clearing
status registers	8-136
CME-bit · · · · · · · · · · · · · · · · 6-17, 8-131
Colon · · · · · · · · · · · · · · · · · · · · 3-8, 3-10 Command
Error · · · · · · · · · · · · · 3-4, 3-17, 8-131 Error (CME)	6-17
Header	3-10
Tree	3-10
Command Error (CME)
Code list	7-2
Command tree	3-8
Commands	3-20
*CLS· · · · · · · · · · · · · · · · · 3-20, 8-128
*DDT	8-128
*DMC · · · · · · · · · · 3-13, 8-127, 8-129
*EMC · · · · · · · · · · · · · · · · 3-14, 8-130
*ESE· · · · · · · · · · · · · · · · 8-127, 8-131
*ESR?	8-132
*GMC? · · · · · · · · · · · · · · · 3-15, 8-132
*IDN?	8-133
*LMC · · · · · · · · · · · · · · · 8-127, 8-133
*LMC?	3-15
*LRN?	8-134
*OPC	8-134
*OPC?	8-135
*OPT?	8-135
*PMC · · · · · · · · · · 3-14, 8-127, 8-136
*PSC · · · · · · · · · · · · · · · 8-127, 8-136
*PUD	8-137
*RCL	8-137
*RMC	8-138
*RST · · · · · · · · · · · · · · · 8-127, 8-138
*SAV	8-139
*SRE · · · · · · · · · · · · · · · · 6-13, 8-140
*STB?· · · · · · · · · · · · · · · 8-127, 8-141
*TRG· · · · · · · · · · · · · 6-25, 8-8, 8-141
*TST?· · · · · · · · · · · · · · · 8-127, 8-142
*WAI	8-142
:ABORt	8-4
:ACQuisition:APERture	8-92
:Acquisition:HOFF	8-92
:ACQuisition:HOFF	8-92
:Acquisition:HOFF:TIMe	8-93
:ARM	8-7
:ARM:COUNt	8-6
:ARM:LAYer2:SOURce	8-8
:ARM:SEQuence:LAYer1:COUNt · 8-6
:ARM:SEQuence1:LAYer1:SLOPe 8-8
:ARM:SEQuence2:SLOPe	8-9
:ARM:SEQuence2:SOURce	8-10
:ARM:SLOPe	8-8
:ARM:SOURce	8-9
:ARM:STARt	8-7
:ARM:STARt:LAYer1:COUNt	8-6
:ARM:STARt:LAYer1:SLOPe	8-8
:ARM:STOP:SLOPe	8-9
:ARM:STOP:SOURce	8-10
:ARM:STOP:TIMe	8-10
:AUTO	8-93
:CALCulate:AVERage:ALL?	8-12
:CALCulate:AVERage:COUNt	8-12
:CALCulate:AVERage:COUNt: CURRent?	8-13
:CALCulate:AVERage:STATe	8-13
:CALCulate:AVERage:TYPE	8-14
:CALCulate:DATA	8-14
:CALCulate:DATA?	8-14
:CALCulate:IMMediate	8-15
:CALCulate:LIMit	8-15
:CALCulate:LIMit(:STATe) · · 6-3, 8-15

:CALCulate:LIMit:CLEar	8-16
:CALCulate:LIMit:CLEar:AUTO	8-16
:CALCulate:LIMit:FAIL	8-17
:CALCulate:LIMit:FCOunt:
LOWer?	8-17
:CALCulate:LIMit:FCOunt:TOTal?8-18
:CALCulate:LIMit:LOWer:STATe · 8-20
:CALCulate:LIMit:PCOunt?	8-19
:CALCulate:LIMit:UPPer	8-20
:CALCulate:LIMit:UPPer:STATe · 8-21
:CALCulate:MATH	8-21
:CALCulate:MATH:STATe	8-22
:CALCulate:STATe	8-22
:CALCulate:TOTalize:TYPE	8-23
:CALibration:INTerpolator:AUTO· 8-26
:CONFigure	8-28
:CONFigure:(Meas Func)	8-28
:CONFigure:ARRay	8-29
:CONFigure:ARRay:(Meas Func) 8-29
:CONFigure:DCYCle	8-64
:CONFigure:FREQuency	8-60
:CONFigure:FREQuency:
BURSt :PRF	8-62
:CONFigure:FREQuency: BURSt:CARRier	8-61
:CONFigure:FREQuency:RATio · 8-63
:CONFigure:FTIMe	8-70
:CONFigure:MAXimum	8-65
:CONFigure:MINimum	8-65
:CONFigure:NDUTycycle	8-64
:CONFigure:NWIDth	8-71
:CONFigure:PDUTycycle	8-64
:CONFigure:PERiod	8-68
:CONFigure:PERiod:AVERage? · 8-68
:CONFigure:PHASe	8-69
:CONFigure:PTPeak	8-66
:CONFigure:PWIDth	8-71
:CONFigure:RTIMe	8-69
:CONFigure:TINTerval	8-70
:CONFigure:TOTalize	8-30
:CONFigure:TOTalize:
CONTinuous	8-30
:DISPlay:ENABle	8-32
:FETCh:ARRay?	8-34
:FETCh?	8-34
:FORMat	8-38
:FORMat:BORDer	8-38
:FORMat:SMAX	8-39
:FORMat:TINFormation	8-40
:FREQuency:POWer:UNIT	8-96
:FREQuency:RANGE:LOWER	8-96
:FREQuency:REGRession	8-97
:FUNCtion	8-97
:HCOPy:SDUMp:DATA	8-42
:HF:ACQuisition	8-99
:HF:FREQuency:CENTer	8-99
:INITiate	8-44
:INITiate:CONTinuous	8-44
:INPut:ATTenuation	8-46
:INPut:COUPling	8-46
:INPut:FILTer	8-47
:INPut:FILTer:DIGital	8-47
:INPut:FILTer:DIGital:
FREQuency	8-48
:INPut:IMPedance	8-48
:INPut:LEVel	8-49
:INPut:LEVel:AUTO	8-49
:INPut:LEVel:RELative	8-50
:INPut:SLOPe	8-51
:MEASure:(Measuring Function)?8-56
:MEASure:ARRay:
(Measuring Function)?	8-57
:MEASure:ARRay:STSTamp?	8-72
:MEASure:ARRay:TIError?	8-75
:MEASure:ARRay:TSTAmp?	8-73
:MEASure:ARRay?	8-57
:MEASure:DCYCle?	8-64
:MEASure:FALL:TIME?	8-70
:MEASure:FREQuency:BTBack? 8-74
:MEASure:FREQuency:BURSt: CARRier?	8-61
:MEASure:FREQuency:BURSt:
PRF?	8-62
:MEASure:FREQuency:BURSt? · 8-61

:MEASure:FREQuency:POWer? 8-61
:MEASure:FREQuency:PRF	8-62
:MEASure:FREQuency:RATio	8-63
:MEASure:FREQuency:RATio?	8-63
:MEASure:FREQuency?	8-60
:MEASure:FTIMe?	8-70
:MEASure:MAXimum?	8-65
:MEASure:MEMory ?	8-58
:MEASure:MEMory?	8-58
:MEASure:MEMory?	8-58
:MEASure:MEMory<N>?	8-58
:MEASure:MINimum?	8-65
:MEASure:NCYCles?	8-63
:MEASure:NDUTycycle?	8-64
:MEASure:NSLEwrate?	8-67
:MEASure:NWIDth?	8-71
:MEASure:PDUTycycle?	8-64
:MEASure:PERiod:AVERage?	8-68
:MEASure:PERiod:BTBack?	8-74
:MEASure:PERiod?	8-68
:MEASure:PHASe?	8-69
:MEASure:PSLEwrate?	8-67
:MEASure:PTPeak?	8-66
:MEASure:PWIDth?	8-71
:MEASure:RISE:TIME?	8-69
:MEASure:RTIMe?	8-69
:MEASure:TINTerval?	8-70
:MEASure:VOLT:MAXimum?	8-65
:MEASure:VOLT:MINimum?	8-65
:MEASure:VOLT:PTPeak?	8-66
:MEASure:VOLT:RATio?	8-66
:MEMory:DATA:RECord:COUNt? 8-78
:MEMory:DATA:RECord:DELete· 8-78
:MEMory:DATA:RECord:FETCh:
ARRay?	8-79
:MEMory:DATA:RECord:FETCh:
STARt	8-80
:MEMory:DATA:RECord:FETCh? 8-79
:MEMory:DATA:RECord:NAME? 8-80
:MEMory:DATA:RECord:SAVE	8-81
:MEMory:DELete:MACRo 8-82, 8-138
:MEMory:FREE:MACRo?	8-82
:MEMory:NSTates?	8-83
:OUTPut:POLarity	8-86
:OUTPut:TYPE	8-86
:READ:ARRay?	8-89
:READ?	8-88
:ROSCillator:SOURce	8-100
:SENSe:Acquisition:APERture	8-92
:SENSe:Acquisition:HOFF	8-92
:SENSe:Acquisition:HOFF:TIMe· 8-93
:SENSe:FREQuency:BURSt: APERture	8-94
:SENSe:FRE-
Quency:BURSt:STARt:DELay	8-95
:SENSe:FRE-
Quency:BURSt:SYNC:PERiod	8-95
:SENSe:FRE-
Quency:PREScaler:STATe	8-94
:SENSe:FREQuency:RANGe:
LOWer	8-96
:SENSe:FUNCtion	8-97
:SENSe:ROSCillator:SOURce · 8-100
:SENSe:TOTalize:GATE	8-102
:SOURce:PULSe:PERiod	8-104
:SOURce:PULSe:WIDTh	8-104
:STATus:DREGister0:ENABle	8-106
:STATus:DREGister0?	8-106
:STATus:OPERation:
CONDition?	8-107
:STATus:OPERation:ENABle	8-108
:STATus:OPERation?	8-109
:STATus:PRESet	8-109
:STATus:QUEStionable:
CONDition?	8-110
:STATus:QUEStionable:ENABle 8-111
:STATus:QUEStionable?	8-111
:SYSTem:COMMunicate:GPIB: ADDRess	8-114
:SYSTem:ERRor?	8-114
:SYSTem:INSTrument:TBASe: LOCK?	8-115
:SYSTem:LANGuage	8-115

:SYSTem:PRESet	8-116
:SYSTem:SET	8-116
:SYSTem:TALKonly	8-117
:SYSTem:TEMPerature?	8-117
:SYSTem:TOUT	8-118
:SYSTem:TOUT:AUTO	8-118
:SYSTem:TOUT:TIME	8-119
:SYSTem:UNPRotect	8-119
:TEST:SELect	8-122
:TIError:FREQuency	8-101
:TIError:FREQuency:AUTO	8-100
:TINTerval:AUTO	8-101
:TOTalize:GATE	8-102
:TRIGger (:SEQuence1):
COUNt	8-124
:TRIGger(:STARt):COUNt	8-124
:TRIGger:COUNt	8-124
:TRIGger:SOURce	8-124
:TRIGger:TIMer	8-125
CALCulate:LIMit:FCOunt:
UPPer?	8-18
CALCulate:LIMit:LOWer	8-19
RCL	8-127
SOC?	8-107
SOEn	8-108
SOEv?	8-109
Commands· · · · · · · · · · · · · · · · · · · · · · · 
:ACQuisition:HOFF:TIME	8-93
Common Commands · · · · · · 3-8, 8-127
Configure· · · · · · · · · · · · · · · · · 5-5, 8-28
Array	8-29
Description	6-7
Function · · · · · · · · · · · · · · · 8-27, 8-53
Scalar	8-28
Continuously Initiated	8-44
Control function	1-5
Conventions	1-3
Coupling
See AC/DC
Cutoff frequency	8-47
CW	8-61
D
Data
Recalculate	8-15
Data Type	8-38
DC coupling See AC/DC
DCL	3-19
DDE-bit · · · · · · · · · · · · · · · · 6-17, 8-131
Deadlock	3-5
Decimal data	3-11
Default	8-138
Presetting the counter	8-116
Deferred commands	3-5
Define Macro	8-129
Delay
After external start arming	8-7
After External Stop Arming	8-9
Delete one Macro· · · · 3-15, 8-82, 8-138
Device clear· · · · · · · · · · · · · · · 1-5, 3-19 Device dependent Error (DDE)
· · · · · · · · · · · · · · · · · · · · · · · 6-17, 8-131
Device initialization	3-19
Device Setup	8-134
Device specific errors · · · · · · · 3-4, 3-18
Standardized	7-11
Device Status	8-140
Device Status Register
Enable	8-106
Event	8-106
No. 0	8-106
Device Trigger
define	8-128
Device Trigger,	1-6
Digital Filter	8-47
Display
Enable	8-32
On/Off	8-32
State	8-32
Subsystem	8-31
Double quotes	3-12

DREG0	8-141
Duration
See Pulse width
E
EAV· · · · · · · · · · · · · · 6-13, 8-114, 8-140 Enable
Calculation	8-22
Display	8-32
Macros	8-130
Mathematics	8-22
Monitoring of Parameter Limits	8-15
Service Request	8-140
Standard Event Status	8-131
Statistics	8-13
Error
ASCII description	8-114
Available	8-140
Clearing queue	8-128
Command	7-2
Device specific, code list	7-13
Escape from condition	3-19
Execution	7-7
In self test	8-142
Message available	6-13
Query, code list	7-12
Queue · · · · · · · · · · · · · 3-17, 6-13, 7-2
Reporting	3-17
Standardized device specific list · 7-11 Standardized numbers	3-17
ESB · · · · · · · · · · · · · · · · · · 8-131, 8-140 Escape from erroneous conditions· 3-19 Event
Clearing registers	8-128
Detection	6-24
Read Device Status Event
Register	8-106
Status bit · · · · · · · · · · · · 8-131, 8-140 Status Register	8-132
Example language	1-4
EXE-bit · · · · · · · · · · · · · · · · 6-17, 8-131
Execution
Control	3-4
Error · · · · · · · · 3-4, 3-18, 6-17, 8-131 Error code list	7-7
Expression	8-21
data	3-12
Ext. ref.	8-100
External reference	8-100
F
Fail
Limit	8-17
Fall time
Measurements	8-70
Fast
Autotrigger	8-96
Fetch	5-6
An Array of Results	8-35
Array	8-35
Calcutated Data	8-14
Description	6-8
Function	8-32
One Result	8-34
Several measurement results	8-35
Fixed Trigger Level	8-49
Format
Examples	8-39
Subsystem	8-37
Formula
Mathematics	8-21
Macro	8-82
Freerun	8-44
Frequency
Low limit for volt/autotrig	8-96
Measurement	8-60
Ratio measurements	8-63
Front panel memories	8-139
G
Gate time	8-92
GET · · · · · · · · · · · · · · · 6-25, 8-8, 8-141

Get Macro	8-132
GPIB Address · · · · · · · · · · · · 1-4, 8-114 Group Execute Trigger	8-141
H
Hard Copy	8-41
Header path	3-10
Header separator	3-8
High Speed Voltage Measurements 8-96 Hold Off
On/Off	8-92
Setting time	8-93
Time	8-93
Time range	8-93
I
Identification query	8-133
Idle state	6-24
IFC	3-19
Immediate mode	8-8
Impedance	8-48
Initiate · · · · · · · · · · · · · · · · · · · 3-19, 5-6
Continuous	6-24
Continuously	8-44
Description	6-8
Immediate	6-24
Measurement	8-44
Subsystem	8-43
Initiated state	6-24
Input
AC/DC	8-46
Attenuation	8-46
Coupling	8-46
Impedance	8-48
Selecting	6-9
Selecting channel	8-97
Subsystems	8-45
INPut block	5-3
Input C Acquisition	8-99
Instrument model	5-2
Interface clear	3-19
Internal reference	8-100
Interpolators
Calibration	8-26
Interrupted	3-5
K
K, L and M	8-21
Keywords	3-11
L
Leaf node	3-10
Learn Device Setup	8-134
Learn Macro	8-133
Level
Fixed trigger	8-49
Limit
Check lower	8-20
Check Upper	8-21
Enable	8-15
Enable monitoring	8-22
Fail	8-17
Monitoring	6-22
Passed	8-106
Set lower	8-19
Set upper	8-20
Limits
Enable Monitoring	8-15
Failure counter auto reset	8-16
Listener function	1-5
Local
Control	1-4
Lockout	3-6
Operation	3-6
Long form	3-8
Low Pass Filter	8-47
Lower case	3-8
Lower Limit
Check	8-20
Fail	8-17
Set	8-19

M
Macro	3-13
Data types	3-13
Define	8-129
Delete · · · · · · · · · · · 3-15, 8-82, 8-138 Delete all	8-136
Description	3-13
Enable	8-130
Get	8-132
How to execute	3-14
Learn	8-133
Memory states	8-83
Names	3-13
Purge	8-136
Mathematics
Enable	8-22
Select expression	8-21
MAV · · · · · · · · · · · · · · · · · · · 3-19, 8-140
MAX · · · · · · · · · · · · · · · · · · · · 3-11, 8-14
MEAN	8-14
Measure	5-5
Array	8-57
Description	6-7
Functions	8-59
Once	8-56
Scalar	8-56
Volt neg. peak	8-65
Volt peak	8-65
Measurement
Abort	8-4
Continuously initiated	8-44
Fetch Results	8-35
Function	5-5
High Speed Voltage	8-96
Initiate	8-44
No. of, on ext arm start	8-124
No. on each bus arm	8-6
Started (MST)	6-19
Status	8-107
Stopped (MSP)	6-19
Trigger	8-141
Measurement Function	8-53
Measurement Time	8-92
Setting	8-92
Measuring
Burst CW	8-61
Duty Cycle	8-64
Fall Time	8-70
Frequency	8-60
Frequency Back-to-Back	8-74
Frequency ratio	8-63
Input selection	6-9
Period	8-68
Period Back-to-Back	8-74
Phase	8-69
PRF	8-62
Pulse width	8-71
Rise Time	8-69
Select function	8-28
Selecting function	8-97
Terminate	8-4
Time Interval	8-70
Time Interval Error (TIE)	8-75
Timed Totalize	8-10
Time-Interval	8-70
Transition time	8-69
Measuring time
Range	8-92
Memory
Fast	8-58
Free for Macros	8-82
Recall and measure fast	8-58
Message
Available	8-140
Exchange Control	3-4
exchange initialization	3-19
terminator	3-5
MIN	8-14
Mnemonic conventions	1-3
Mnemonics	3-8
Monitor

Limits	· 6-3, 8-15
Monitor of low limit	6-22
of high limit	6-22
MSP-bit	6-19
MSS	8-141
MST-bit	6-19
Multiple measurements See Array
Multiple queries	3-9
N
Negative slope	8-51
Non-decimal data	3-12
Notation habit	3-9
NRf	3-11
Numeric data	3-11
Numeric expression data	3-12
O
OFL-bit	6-20
On/Off, Hold Off	8-92
OPC-bit	6-17
Operation
Complete	8-134
Complete (OPC) · · · · · · · 6-17, 8-131 Complete Query	8-135
Operation Status
Bit	8-140
Bits in register	6-19
Enable	8-108
Event	8-109
Group Overview	6-18
OPR	8-140
Optional nodes	3-10
Options
Identification	8-135
Output
Configuration	8-86
Polarity	8-86
Output queue	6-13
Output Subsystem	8-85
Overflow	6-20
Message	3-17
Status	8-110
Override
Bus Arm	8-7
P
Parallel poll,	1-5
Parameter list	3-12
Parenthesis	3-12
Parser	3-4
Peak-to-Peak
Voltage	8-66
Period measurements	8-68
Phase	8-69
PMT · · · · · · · · · · · · · · · · · · · · · 3-7, 3-10
PON-bit · · · · · · · · · · · · · · · · 6-16, 8-131 Positive slope	8-51
Power
RF input	8-61
Power On· · · · · · · · · · · · · · · 6-16, 8-131
Status Clear	8-136
Preset	8-116
Status at power on	8-136
Status registers	8-109
PRF	8-62
PRF Measurement	8-62
Program message terminator · 3-7, 3-10 Program messages	3-7
Programming examples
Block measurements	4-5
Fast measurements	4-8
Individual measurements	4-3
USB communication	4-11
Programming Examples
Continuous Measurements	4-13
Protected User Data	8-137
Pulse
Repetition Frequency	8-62
Width	8-71
Purge Macro	8-136

Q
QUE	8-140
Query
Error · · · · 3-4, 3-18, 6-17, 7-12, 8-131
Multiple	3-9
Questionable Data/signal	8-140
Condition	8-110
Enable	8-111
Event	8-111
Status group	6-20
Quotes	3-12
QYE-bit · · · · · · · · · · · · · · · · 6-17, 8-131
R
Ratio	8-63
Read	5-6
Array	8-89
Function	8-87
One Result	8-88
Scalar	8-88
Read or Send Settings	8-116
Recalculate Data	8-15
Recall · · · · · · · · · · · · · · · · · 8-58, 8-137 Reference
Selection	8-100
REMOTE	1-4
Remote operation	3-6
Remote/local	1-5
Remove
All macros	8-136
One macro	8-138
Repetition	1-3
Request Control (RQC)· · · · 6-17, 8-131 Request Service	8-140
Reset · · · · · · · · · · · · 3-19, 8-116, 8-138 Response
Data	3-9
Data Format	8-45
Data Type	6-6
Message	3-5
Message terminator	3-9
Messages	3-7
Result
Fetch one	8-34
Reading	8-88
Retrieve
Front panel setting	8-137
Measurement result	8-34
Rise Time
Measurements	8-69
Trigger levels	8-50
Rmt	3-9
Root level	3-8
Root node	3-8
RQC-bit · · · · · · · · · · · · · · · · 6-17, 8-131
RQS	8-140
RST	3-20
S
Sample Size for Statistics	8-12
Save	8-139
SCPI	3-2
Screen Dump	8-42
SDC	3-19
SDEV	8-14
Select Mathematical Expression	8-21
Selective device clear	3-19
Self Test
Activate	8-142
Select	8-122
Semicolon	3-8
SEND	1-4
SENSe block	5-3
Sense Command Subsystem	8-91
Sequential commands	3-5
Service Request	3-17
Capability	1-5
Enable	8-140
Set
Lower Limit	8-19
Upper Limit	8-20

Set Basic TIE Frequency	8-101
Settings
Reading	8-116
Short form	3-8
Single quotes	3-12
Single Time Stamp	8-72
Slope	8-51
Arming start	8-8
Stop arming	8-9
Smart Time Interval	8-101
Source
Start arming	8-9
Stop arming	8-10
Source Subsystem	8-103
Speed
Autotrigger	8-96
Voltage measurements, high	8-96
Standard deviation	8-14
Standard Event Status
Enable	8-131
Standard event status register	6-16
Standardized Device specific
errors	7-11
Standardized Error numbers · · 3-17, 7-2 Start arming
Delay	8-7
Slope	8-8
Start measurement	8-44
Start source
Arming	8-9
Start/stop
Totalize	8-102
Statistics
Enable	8-13
Fetch data	8-14
Recalculate data	8-15
Recalculating data	8-15
Sample size	8-12
Sample Size	8-12
Type	8-14
Status
Clear	8-128
Clear data structures	3-20
Enable reporting	8-109
Enabling Standard Event Status 8-131 Event Status Register	8-132
Limit monitor	8-106
Measurement started	8-108
Measurement stopped	8-108
Operation event	8-109
Overflow	8-110
Preset	8-109
Questionable Data/signal	8-110
Questionable Data/signal, Event
· · · · · · · · · · · · · · · · · · · · · · · · · · 8-111
Register structure	3-16
Subsystem	8-105
Timeout	8-110
Unexpected parameter	8-110
Using the reporting · · · · · · 3-16, 6-10 Waiting for bus arming	8-108
Waiting for triggering	8-108
Status byte· · · · · · · · · · · · · · · 3-16, 6-10
Bit 0	8-106
Bit 2	6-13
Bit 3	8-110
Bit 5	8-131
Bit 6	8-141
Bit 7	8-108
Query	8-141
Reading · · · · · · · · · · · · · · 6-13, 8-141 Status Register
Read	8-107
Status reporting · · · · · · · · · · · 3-16, 6-10 Stop Arming
Slope	8-9
Source	8-10
Store
Front panel settings	8-139
String data	3-12
Subnodes	3-8
Suffixes	3-11

Summary
Measurement commands	6-8
Of input amplifier settings	6-6
Syntax
and Style	3-7
System Subsystem	8-113
T
Talker function	1-5
Terminate
Measurement	8-4
Terminator	3-8
50ohms/1Mohm	8-48
Test
Activating	8-142
Selecting internal self-test	8-122
Subsystem	8-121
Time
Hold Off	8-93
Interval	8-70
Measure Rise	8-69
Selecting Measurement Time	8-92
Time out
For measurement (TIO)	6-20
Time Stamp	8-73
Timebase
External/internal	8-100
Timeout
On/Off	8-118
Set	8-119
Status	8-110
TIO-bit	6-20
Totalize
Manually	8-30
Trigger	6-25
See Also	Command: *TRG
No. of, on ext arm start	8-124
Slope	8-51
Subsystem · · · · · · · · · · · · 8-13, 8-123 Trigger level
Fixed	8-49
Trigger Level
Automatic	8-49
Fixed	8-49
Truncation rules	1-3
Type, Statistical	8-14
U
UEP-bit · · · · · · · · · · · · · · · · 6-20, 8-110 Unexpected parameter (UEP)	6-20
Status	8-110
Unit separator	3-8
Unprotect	8-119
Unterminated	3-5
Upper case	3-8
Upper Limit
Check	8-21
Fail	8-17
Set	8-20
URQ-bit · · · · · · · · · · · · · · · · 6-16, 8-131 USB Interface	1-6
User data	8-119
User request (URQ) · · · · · · 6-16, 8-131
V
Variable hysteresis
Auto levels	8-50
Volt
High Speed Measurements	8-96
Negative Peak	8-65
Peak	8-65
Peak-to-Peak	8-66
W
WAI	5-4
Wait for bus arming (WFA)	6-19
Waiting for bus arming
Status	8-108
Waiting for trigger and/or
ext. arming (WFT)	6-19
Waiting for triggering
Status	8-108

Wait-to-continue	8-142
WFA-bit	6-19
WFT-bit	6-19
X
X1/X10 attenuation	8-46
Longform
Shortform
:MEASURE
:MEAS
:NEGATIVE
:NEG
:DREGISTER0
:DREG0
:EXTERNAL4
:EXT4
Description,
Code
Source handshake,
SH1
Acceptor handshake,
AH1
Control function,
C0
Talker Function,
T6
Listener function,
L4
Service request,
SR1
Remote/local function,
RL1
Parallel poll,
PP0
Device clear function,
DC1
Device trigger function,
DT1
Bus drivers,
E2
PARAMETER
VALUE/ SETTING
Inputs A & B
Inputs A & B
Trigger Level
AUTO
Impedance
1 M
Manual Attenuator
1X
Coupling
AC
Trigger Slope
POS
Filter
OFF
Arming
Arming
Start
OFF
Start Slope
POS
Start Arm Delay
0
Stop
OFF
Stop Slope
POS
Source
IMM
Hold-Off
Hold-Off
Hold-Off State
OFF
Hold-Off Time
200 µs
Time-Out
Time-Out
Time-Out State
OFF
Time-Out Time
100 ms
Statistics
Statistics
Statistics State
OFF
No. of Samples
100
No. of Bins
20
Pacing State
OFF
Pacing Time
20 ms
State
Purpose
IDLE
Wait for messages
READ
Read and execute mes- sages
QUERY
Store responses to be sent
SEND
Send responses
RE- SPONSE
Complete sending re- sponses
DONE
Finished sending re- sponses
DEADLOCK
The device cannot buffer more data
Action,
Reason
Untermin- ated,
The controller attempts to read the device without first having sent a com- plete query message
Interrupted,
The device is interrupted by a new program mes- sage before it finishes sending a response mes- sage
J
NL^END
This is <new line>


code sent concur-


rently with the


END message on


the GPIB.

NL
This is the <new


line> code.

<dab>^END
This is the END


message sent con-


currently with the


last data byte


<dab>.
Error Class
Range of Error Num- bers
Standard Event
Register
Command Error
–100 to
–199
bit 5 - CME
Execution Error
–200 to
–299
bit 4 - EXE
Device Specific Error
–300 to
–399
+100 to
+32767
bit 3 - DDE
Query Error
–400 to
–499
bit 2 -QYE
Function
Instrument Type
Examples
Signal ac- quisition
Sense in- struments
Voltmeter, Oscilloscope, Counter
Signal genera- tion
Source in- struments
Pulse genera- tor,
Power supply
Signal routing
Switch in- struments
Scanner,
(de)-multiplexer
Versatility of Measurement Commands
Versatility of Measurement Commands
MEASure?
Simple to use; few additional possibili- ties.
CONFigure READ?
Somewhat more difficult; some extra possibilities.
CONFigure INITiate FETCh?
Most difficult to use; many extra features.
Versatility of measurement com- mands
Versatility of measurement com- mands
MEASure?
Simple to use, few addi- tional possibilities.
CONFigure READ?
Somewhat more difficult, but some extra possibili- ties.
CONFigure INITiate FETCh?
Most difficult to use, but many extra features.
Condition Register
Condition Register
Condition Register
Condition Register
Condition Register
Condition Register
Condition Register







Event Register
Event Register
Event Register
Event Register
Event Register
Event Register
Event Register







Enable Register
Enable Register
Enable Register
Enable Register
Enable Register
Enable Register
Enable Register







Logical OR
Logical OR
Logical OR
Logical OR
Logical OR
Logical OR
Logical OR

Idle

Idle

Idle

ated


No initia
Initiated
Initiated
Initiated

ated

Co
of AR
Wait for ARM
Wait for ARM
Wait for ARM
ns ied

Co No loo
Wait for TRIG
Wait for TRIG
Wait for TRIG
ns ied

Instr Actio com
Instrument Actions
Instrument Actions
Instrument Actions
Command Errors
Command Errors
Command Errors
Error Number
Error Description
Description/Explanation/Examples
0
No error

–100
Command error
This is the generic syntax error for devices that can- not detect more specific errors. This code indicates only that a Command Error defined in IEEE-488.2,
11.5.1.1.4 has occurred.
–101
Invalid character
A syntactic element contains a character which is in- valid for that type; for example, a header containing an ampersand, SETUP&. This error might be used in place of errors –114, –121, –141, and perhaps some others.
–102
Syntax error
An unrecognized command or data type was encoun- tered; for example, a string was received when the counter does not accept strings.
–102
Syntax error; unrec- ognized data
An unrecognized command or data type was encoun- tered; for example, a string was received when the counter does not accept strings.
–103
Invalid separator
The parser was expecting a separator and encoun- tered an illegal character; for example, the semico- lon was omitted after a program message unit,
EMC1:CH1:VOLTS5.
–104
Data type error
The parser recognized a data element different than one allowed; for example, numeric or string data was expected but block data was encountered.
Command Errors
Command Errors
Command Errors
Error Number
Error Description
Description/Explanation/Examples
–105
GET not allowed
A Group Execute Trigger was received within a pro- gram message (see IEEE-488.2, 7.7).
–108
Parameter not al- lowed
More parameters were received than expected for the header; for example, the EMC common com- mand accepts only one parameter, so receiving
EMC0,,1 is not allowed.
–109
Missing parameter
Fewer parameters were received than required for the header; for example, the EMC common com-
mand requires one parameter, so receiving EMC is not allowed.
–110
Command header error
An error was detected in the header. This error message is used when the counter cannot detect the more specific errors described for errors –111 though –119.
–111
Header separator error
A character that is not a legal header separator was encountered while parsing the header; for example, no space followed the header, thus GMC"MACRO"
is an error.
–112
Program mnemonic too long
The header contains more than 12 characters (see IEEE-488.2, 7.6.1.4.1).
–113
Undefined header
The header is syntactically correct, but it is unde-
fined for this specific counter; for example, XYZ is not defined for any device.
–114
Header suffix out of range
Indicates that a non-header character has been en- countered in what the parser expects is a header el- ement.
–120
Numeric data error
This error, as well as errors –121 through –129, are generated when parsing a data element that ap- pears to be of a numeric type. This particular error message is used when the counter cannot detect a more specific error.
–120
Numeric data error; overflow from con- version
This error, as well as errors –121 through –129, are generated when parsing a data element that ap- pears to be of a numeric type. This particular error message is used when the counter cannot detect a more specific error.
–120
Numeric data error; underflow from con- version
This error, as well as errors –121 through –129, are generated when parsing a data element that ap- pears to be of a numeric type. This particular error message is used when the counter cannot detect a more specific error.
–120
Numeric data error; not a number from conversion
This error, as well as errors –121 through –129, are generated when parsing a data element that ap- pears to be of a numeric type. This particular error message is used when the counter cannot detect a more specific error.
–121
Invalid character in number
An invalid character for the data type being parsed was encountered; for example, an alpha in a deci- mal numeric or a “0" in octal data.
Command Errors
Command Errors
Command Errors
Error Number
Error Description
Description/Explanation/Examples
–123
Exponent too large
The magnitude of the exponent was larger than 32000 (see IEEE-488.2, 7.7.2.4.1).
–124
Too many digits
The mantissa of a decimal numeric data element con- tained more than 255 digits excluding leading zeros (see IEEE-488.2, 7.7.2.4.1).
–128
Numeric data not al- lowed
A legal numeric data element was received, but the counter does not accept it in this position for the header.
–130
Suffix error
This error as well as errors –131 through –139 is generated when parsing a suffix. This particular er- ror message is used when the counter cannot detect a more specific error.
–131
Invalid suffix
The suffix does not follow the syntax described in IEEE-488.2, 7.7.3.2, or the suffix is inappropriate for this counter.
–134
Suffix too long
The suffix contained more than 12 characters (see IEEE-488.2, 7.7.3.4).
–138
Suffix not allowed
A suffix was encountered after a numeric element that does not allow suffixes.
–140
Character data error
This error as well as errors 141 through –149 is gener- ated when parsing a character data element. This par- ticular error message is used when the counter cannot detect a more specific error.
–141
Invalid character data
Either the character data element contains an invalid character or the particular element received is not valid for the header.
–144
Character data too long
The character data element contains more than 12 characters (see IEEE-488.2, 7.7.1.4).
–148
Character data not allowed
A legal character data element was encountered where prohibited by the counter.
–150
String data error
This error as well as errors –151 through –159 is gen- erated when parsing a string data element. This partic- ular error message is used when the counter cannot detect a more specific error.
–151
Invalid string data
A string data element was expected, but was invalid for some reason (see IEEE-488.2, 7.7.5.2); for ex- ample, an END message was received before the terminal quote character.
–151
Invalid string data; unexpected end of message
A string data element was expected, but was invalid for some reason (see IEEE-488.2, 7.7.5.2); for ex- ample, an END message was received before the terminal quote character.
Command Errors
Command Errors
Command Errors
Error Number
Error Description
Description/Explanation/Examples
–158
String data not al- lowed
A string data element was encountered but was not al- lowed at this point in parsing.
–160
Block data error
This error as well as errors –161 through –169 is generated when parsing a block data element. This particular error message is used when the instru- ment cannot detect a more specific error.
–161
Invalid block data
A block data element was expected, but was invalid for some reason (see IEEE-488.2, 7.7.6.2); for ex- ample, an END message was received before the length was satisfied.
–168
Block data not al- lowed
A legal block data element was encountered but was not allowed by the counter at this point in pars- ing.
–170
Expression data er- ror
This error as well as errors –171 through –179 is generated when parsing an expression data ele- ment. This particular error message is used if the counter cannot detect a more specific error.
–170
Expression data er- ror; floating-point underflow
The floating-point operations specified in the expres- sion caused a floating-point error.
–170
Expression data er- ror; floating-point overflow
The floating-point operations specified in the expres- sion caused a floating-point error.
–170
Expression data er- ror; not a number
The floating-point operations specified in the expres- sion caused a floating-point error.
–170
Expression data er- ror; different number of channels given
Two channel list specifications, giving primary and secondary channels for 2-channel measurements, contained a different number of channels.
Command Errors
Command Errors
Command Errors
Error Number
Error Description
Description/Explanation/Examples
–171
Invalid expression data
The expression data element was invalid (see IEEE-488.2, 7.7.7.2); for example, unmatched pa- rentheses or an illegal character were used.
–171
Invalid expression data; bad mnemonic
A mnemonic data element in the expression was not valid.
–171
Invalid expression data; illegal element
The expression contained a hexadecimal element not permitted in expressions.
–171
Invalid expression data; unexpected end of message
End of message occurred before the closing paren- thesis.
–171
Invalid expression data; unrecognized expression type
The expression could not be recognized as either a mathematical expression, a data element list or a channel list.
–178
Expression data not allowed
A legal expression data was encountered but was not allowed by the counter at this point in parsing.
–180
Macro error
This error as well as errors –181 through –189 is generated when defining a macro or executing a macro. This particular error message is used when the counter cannot detect a more specific error.
–181
Invalid outside macro definition
Indicates that a macro parameter placeholder ($<number) was encountered outside of a macro definition.
–183
Invalid inside macro definition
Indicates that the program message unit sequence,
sent with a DDT or DMC command, is syntacti- cally invalid (see IEEE-10.7.6.3).
–184
Macro parameter error
Indicates that a command inside the macro defini- tion had the wrong number or type of parameters.
–184
Macro parameter error; unused pa- rameter
The parameter numbers given are not continuous; one or more numbers have been skipped.
–184
Macro parameter er- ror; badly formed placeholder
The’$’ sign was not followed by a single digit be- tween 1 and 9.
–184
Macro parameter error; parameter count mismatch
The macro was invoked with a different number of parameters than used in the definition.
Execution errors
Execution errors
Execution errors
Error Number
Error Description
description/explanation/examples
–200
Execution error
This is the generic syntax error for devices that can- not detect more specific errors. This code indicates only that an Execution Error as defined in
IEEE-488.2, 11.5.1.1.5 has occurred.
–210
Trigger error

–211
Trigger ignored
Indicates that a GET, TRG, or triggering signal was received and recognized by the counter but was ig- nored because of counter timing considerations; for example, the counter was not ready to respond.
–212
Arm ignored
Indicates that an arming signal was received and recognized by the counter but was ignored.
–213
Init ignored
Indicates that a request for a measurement initiation was ignored because another measurement was al- ready in progress.
–214
Trigger deadlock
Indicates that the trigger source for the initiation of a measurement is set to GET and subsequent mea- surement query is received. The measurement can- not be started until a GET is received, but the GET would cause an INTERRUPTED error.
–215
Arm deadlock
Indicates that the arm source for the initiation of a measurement is set to GET and subsequent mea- surement query is received. The measurement can- not be started until a GET is received, but the GET would cause an INTERRUPTED error.
–220
Parameter error
Indicates that a program-data-element related error occurred. This error message is used when the counter cannot detect the more specific errors –221 to –229.
–221
Settings conflict
Indicates that a legal program data element was parsed but could not be executed due to the current counter state (see IEEE-488.2, 6.4.5.3 and 11.5.1.1.5.)
–221
Settings conflict; PUD memory is pro- tected
Indicates that a legal program data element was parsed but could not be executed due to the current counter state (see IEEE-488.2, 6.4.5.3 and 11.5.1.1.5.)
–221
Settings conflict; in- valid combination of channel and function
Indicates that a legal program data element was parsed but could not be executed due to the current counter state (see IEEE-488.2, 6.4.5.3 and 11.5.1.1.5.)
Execution errors
Execution errors
Execution errors
Error Number
Error Description
description/explanation/examples
–222
Data out of range
Indicates that a legal program data element was parsed but could not be executed because the inter- preted value was outside the legal range as defined by the counter (see IEEE-488.2, 11.5.1.1.5.).
–222
Data out of range; exponent too large
The expression was too large for the internal float- ing-point format.
–222
Data out of range; below minimum
Data below minimum for this function/parameter.
–222
Data out of range; above maximum
Data above maximum for this function/ parameter.
–222
Data out of range; (Save/recall memory number)
A number outside 0 to 19 was given for the save/re- call memory.
–223
Too much data
Indicates that a legal program data element of block, expression, or string type received that contained more data than the counter could handle due to memory or related counter-specific requirements.
–223
Too much data;
PUD string too long
Indicates that a legal program data element of block, expression, or string type received that contained more data than the counter could handle due to memory or related counter-specific requirements.
–223
Too much data;String or block too long
Indicates that a legal program data element of block, expression, or string type received that contained more data than the counter could handle due to memory or related counter-specific requirements.
–224
Illegal parameter value
Used where exact value, from a list of possible val- ues, was expected.
–230
Data corrupt or stale
Possibly invalid data; new reading started but not completed since last access.
–231
Data questionable

–231
Data questionable; one or more data el- ements ignored
One or more data elements sent with a MEASure or CONFigure command was ignored by the counter.
–240
Hardware error
Indicates that a legal program command or query could not be executed because of a hardware prob- lem in the counter. Definition of what constitutes a hardware problem is completely device specific. This error message is used when the counter cannot de- tect the more specific errors described for errors
–241 through –249.
Execution errors
Execution errors
Execution errors
Error Number
Error Description
description/explanation/examples
–241
Hardware missing
Indicates that a legal program command or query could not be executed because of missing counter hardware; for example, an option was not installed. Definition of what constitutes missing hardware is com- pletely device specific.
–241
Hardware missing; (prescaler)"
Indicates that a legal program command or query could not be executed because of missing counter hardware; for example, an option was not installed. Definition of what constitutes missing hardware is com- pletely device specific.
–254
Media full
Indicates that a legal program command or query could not be executed because the media was full; for example, there is no room on the disk. The defi- nition of what constitutes a full media is device spe- cific.
–258
Media protected
Indicates that a legal program command or query could not be executed because the media was pro- tected; for example, the write-protect tab on a disk was present. The definition of what constitutes pro- tected media is device specific.
–260
Expression error
Indicates that an expression-program data-element- related error occurred. This error message is used when the counter cannot detect the more specific errors described for errors –261 through –269.
–261
Math error in ex- pression
Indicates that a syntactically correct expression pro- gram data element could not be executed due to a math error; for example, a divide-by-zero was at- tempted.
–270
Macro error
Indicates that a macro-related execution error oc- curred. This error message is used when the counter cannot detect the more specific error described for er- rors –271 through –279.
–270
Macro error; out of name space
No room for any more macro names.
–270
Macro error; out of definition space
No room for this macro definition.
–271
Macro syntax error
Indicates that a syntactically correct macro program data sequence, according to IEEE-488.2 10.7.2, could not be executed due to a syntax error within the macro definition (see IEEE-488.2, 10.7.6.3)
–272
Macro execution er- ror
Indicates that a syntactically correct macro program data sequence could not be executed due to some error in the macro definition (see IEEE-488.2, 10.7.6.3)
Execution errors
Execution errors
Execution errors
Error Number
Error Description
description/explanation/examples
–273
Illegal macro label
Indicates that the macro label defined in the DMC command was a legal string syntax, but could not be accepted by the counter (see IEEE-488.2, 10.7.3 and 10.7.6.2); for example, the label was too long, the same as a common command header, or contained invalid header syntax.
–274
Macro parameter error
Indicates that the macro definition improperly used a macro parameter place holder (see IEEE-488.2, 10.7.3).
–275
Macro definition too long
Indicates that a syntactically correct macro program data sequence could not be executed because the string or block contents were too long for the coun- ter to handle (see IEEE-488.2, 10.7.6.1).
–276
Macro recursion er- ror
Indicates that a syntactically correct macro program data sequence could not be executed because the counter found it to be recursive (see IEEE-488.2, 10.7.6.6).
–277
Macro redefinition not allowed
Indicates that a syntactically correct macro label in the DMC command could not be executed because the macro label was already defined (see
IEEE-488.2, 10.7.6.4).
–278
Macro header not found
Indicates that a syntactically correct macro label in
the GMC? query could not be executed because the header was not previously defined.
Standardized Device specific errors
Standardized Device specific errors
Standardized Device specific errors
Error Number
Error Description
description/explanation/examples
–300
Device specific error
This code indicates only that a Device-Dependent Error as defined in IEEE-488.2, 11.5.1.1.6 has oc- curred. Contact your local service center.
–311
Memory error
Indicates that an error was detected in the counter’s memory. Contact your local service center.
–312
PUD memory lost
Indicates that the protected user data saved by the
PUD command has been lost. Contact your local service center.
–314
Save/recall memory lost
Indicates that the nonvolatile calibration data used
by the SAV? command has been lost. Contact your local service center.
–330
Self-test failed
Contact your local service center.
–350
Queue overflow
A specific code entered into the queue in lieu of the code that caused the error. This code indicates that there is no room in the queue and an error occurred but was not recorded.
Query errors
Query errors
Query errors
Error Number
Error Description
description/explanation/examples
–400
Query error
This code indicates only that a Query Error as de- fined in IEEE-488.2, 11.5.1.1.7 and 6.3 has oc- curred.
–410
Query INTERRUPTED
Indicates that a condition causing an INTER- RUPTED Query error occurred (see IEEE-488.2, 6.3.2.3); for example, a query was followed by DAB or GET before a response was completely sent.
–410
Query INTER- RUPTED; in send state
The additional information indicates the IEEE-488.2 message exchange state where the error occurred.
–410
Query INTER- RUPTED; in query state
The additional information indicates the IEEE-488.2 message exchange state where the error occurred.
–410
Query INTER- RUPTED; in re- sponse state
The additional information indicates the IEEE-488.2 message exchange state where the error occurred.
–420
Query UNTERMINATED
Indicates that a condition causing an UNTERMINATED Query error occurred (see
IEEE-488.2, 6.3.2.2); for example, the counter was addressed to talk and an incomplete program mes-
sage was received.
–420
Query UNTERMINATED;
in idle state
The additional information indicates the IEEE-488.2 message exchange state where the error occurred
–420
Query UNTERMINATED;
in read state
The additional information indicates the IEEE-488.2 message exchange state where the error occurred
–420
Query UNTERMINATED;
in send state
The additional information indicates the IEEE-488.2 message exchange state where the error occurred
–430
Query DEADLOCKED
Indicates that a condition causing an DEADLOCKED Query error occurred (see IEEE-488.2, 6.3.1.7); for example, both input buffer and output buffer are full and the counter cannot continue.
–440
Query UNTERMINATED
after indefinite re-
sponse
Indicates that a query was received in the same pro- gram message after an query requesting an indefi- nite response was executed (see IEEE-488.2, 6.5.7.5.7.)
Device specific errors
Device specific errors
Device specific errors
Error Number
Error Description
description/explanation/examples
(1)100
Device operation gave floating-point underflow
A floating-point error occurred during a counter op- eration.
(1)101
Device operation gave floating-point overflow
A floating-point error occurred during a counter op- eration.
(1)102
Device operation gave ‘not a number’
A floating-point error occurred during a counter op- eration.
(1)110
Invalid measure- ment function
The counter was requested to set a measurement function it could not make.
(1)120
Save/recall memory protected
An attempt was made to write in a protected mem- ory.
(1)130
Unsupported com- mand
Indicates a mismatch between bus and counter ca- pabilities.
(1)131
Unsupported boolean command
Indicates a mismatch between bus and counter ca- pabilities.
(1)132
Unsupported deci- mal command
Indicates a mismatch between bus and counter ca- pabilities.
(1)133
Unsupported enu- merated command
Indicates a mismatch between bus and counter ca- pabilities.
(1)134
Unsupported auto command
Indicates a mismatch between bus and counter ca- pabilities.
(1)135
Unsupported single shot command
Indicates a mismatch between bus and counter ca- pabilities.
(1)136
Command queue full; last command discarded
The counter has an internal command queue with room for about 100 commands. A large number of commands arrived fast without any intervening query.
(1)137
Inappropriate suffix unit
A suffix unit was not appropriate for the command. Recognized units are Hz (Hertz), s (seconds), Ohm
() and V (Volt).
(1)138
Unexpected com- mand to device exe- cution
A command reached counter execution which should have been handled by the bus.
(1)139
Unexpected query to device execution
A query reached counter execution which should have been handled by the bus.
(1)150
Bad math expres- sion format
Only a fixed, specific math expression is recognized by the counter, and this was not it.
Device specific errors
Device specific errors
Device specific errors
Error Number
Error Description
description/explanation/examples
(1)160
Measurement bro- ken off
A new bus command caused a running measure- ment to be broken off.
(1)170
Instrument set to default
An internal setting inconsistency caused the instru- ment to go to default setting.
(1)190
Error during calibra- tion
An error has occurred during calibration of the in- strument.
(1)191
Hysteresis calibra- tion failed
The input hysteresis values found by the calibration routine was out of range. Did you remember to re- move the input signal?
(1)200
Message exchange error
An error occurred in the message exchange handler (generic error).
(1)201
Reset during bus in- put
The instrument was waiting for more bus input, but the waiting was broken by the operator.
(1)202
Reset during bus output
The instrument was waiting for more bus output to be read, but the waiting was broken by the operator.
(1)203
Bad message ex- change control state
An internal error in the message exchange handler.
(1)204
Unexpected reason for GPIB interrupt
A spurious GPIB interrupt occurred, not conforming to any valid reason like an incoming byte, address change, etc.
(1)205
No listener on bus when trying to re- spond
This error is generated when the counter is an ac- tive talker, and tries to send a byte on the bus, but there are no active listeners.
(This may occur if the controller issues the device talker address before its own listener address, which
some PC controller cards has been known to do)
(1)210
Mnemonic table er- ror
An abnormal condition occurred in connection with the mnemonics tables (generic error).
(1)211
Wrong macro table checksum found
The macro definitions have been corrupted (could be loss of memory).
(1)212
Wrong hash table checksum found
The hash table has been corrupted. Could be bad memory chips or address logic. Contact your local service center.
(1)213
RAM failure to hold information (hash table)
The memory did not retain information written to it. Could be bad memory chips or address logic. Con- tact your local service center.
(1)214
Hash table overflow
The hash table was too small to hold all mnemon- ics. Ordinarily indicates a failure to read (RAM or ROM) correctly. Contact your local service center.
Device specific errors
Device specific errors
Device specific errors
Error Number
Error Description
description/explanation/examples
(1)220
Parser error
Generic error in the parser.
(1)221
Illegal parser call
The parser was called when it should not be active.
(1)222
Unrecognized input character
A character not in the valid IEEE488.2 character set was part of a command.
(1)223
Internal parser error
The parser reached an unexpected internal state.
(1)230
Response formatter error
Generic error in the response formatter.
(1)231
Bad response for- matter call
The response formatter was called when it should not be active.
(1)232
Bad response for- matter call (eom)
The response formatter was called to output an end of message, when it should not be active.
(1)233
Invalid function code to response formatter
The response formatter was requested to output data for an unrecognized function.
(1)234
Invalid header type to response format- ter
The response formatter was called with bad data for the response header (normally empty)
(1)235
Invalid data type to response formatter
The response formatter was called with bad data for the response data.
(1)240
Unrecognized error number in error queue
An error number was found in the error queue for which no matching error information was found.

Function
Array Size
Array Size
Array Size
Array Size

Function
Interpolator Calibration ON
Interpolator Calibration ON
Interpolator Calibration OFF
Interpolator Calibration OFF
Freq, Per & most other functions
CNT-90
CNT-91
CNT-90
CNT-91
Freq, Per & most other functions
375 k
1.9 M
750 k
3.8 M
Smart Freq & Per
30 k
30 k
30 k
30 k
Volt (Max, Min, PTP)
10 k
10 k
10 k
10 k
Volt Ratio
30 k
30 k
30 k
30 k
Totalize
NA
3.8 M
NA
3.8 M
Normal Program Sequence for Totalizing on A
Normal Program Sequence for Totalizing on A
CONF:TOT:CONT-(@1)
Set up the counter for totalize on A, reset registers
INIT:CONT-ON
Initiate the counter continuously
TOT:GATE-ON
Start totalizing
FETC:ARR?-–1
Read intermediate results without stopping the totalizing
TOT:GATE-OFF
Stop totalizing
FETC:ARR?-–1
Fetch the final result from the totalizing


FORMAT
FORMAT
FORMAT


ASCii
REAL
PACKED
:FORMAT:TINF
OFF

<Val>

#18<Val>

#18<Val>
:FORMAT:TINF
ON

<Val>,<TS>

#18<Val>,#18<TS>

#216<Val><TS>


FORMAT
GPIB MODE
GPIB MODE


FORMAT
NATIVE
COMPATIBLE
ASCii
<LF>
9.91E37
REAL
#18<Binary NaN>
#18<9.91E37 in binary format>
PACKED
#18<Binary NaN>
#18<9.91E37 in binary format>


FORMAT
FORMAT
FORMAT


ASCii
REAL
PACKED
:FORMAT:TINF
OFF

<Val>,<Val>,...

#18<Val>,#18<Val>,...

#ddd<Val><Val><Val>...
:FORMAT:TINF
ON

<Val>,<TS>,<Val>,...

#18<Val>,#18<TS>, #18<Val>,...

#ddd<Val><TS><Val>...
Time to determine trigger levels (typical)
Time to determine trigger levels (typical)
Time to determine trigger levels (typical)
Min. frequency limit (1 Hz)
Default (100 Hz)
Max. frequency limit (50 kHz)
8 s
80 ms
20 ms
Functions and Channels
:FREQuency [ :CW ]
:FREQuency [ :CW ] :RATio

[ -
[ -

‘1 |2 |3 |4 |6 ‘] 
‘1 |2 |3 ,1 |2 |3 ‘] 
:FREQuency:BTBack
[ -
‘1|2‘] 
:FREQuency :BURSt
:FREQuency :PRF
[ -
[ -
‘1 |2 |3 ‘] 
‘1 |2 |3 ‘] 
:NCYCles
[ -
‘1 |2 |3 ‘] 
:PDUTycycle|:DCYCle
:NDUTycycle
[ -
[ -
‘1|2‘] 
‘1|2‘] 
:PERiod
[ -
‘1 |2 |3 ‘] 
:PERiod:BTBack
:PERiod:AVERage
:PHASe
[ -
[ -
[ -
‘1|2‘] 
‘1 |2 |3 ‘] 
‘1 |2 ,1 |2 ‘] 
:PSLEwrate
:NSLEwrate
[ -
[ -
‘1|2‘] 
‘1|2‘] 
:RISE:TIME|:RTIM
[ -
‘1|2‘] 
:FALL:TIME|:FTIM
[ -
‘1|2‘] 
:PWIDth
[ -
‘1|2‘] 
:NWIDth
[ -
‘1|2‘] 
:TINTerval
[ -
‘1 |2 ,1 |2 ‘] 
:STSTamp
:TSTAmp
[ -
[ -
‘1|2‘] 
‘1|2‘] 
[:VOLT]:MAXimum
[ -
‘1|2‘] 
[:VOLT]:MINimum [:VOLT]:PTPeak [:VOLT]:RATIO
[ -
[ -
[ -
‘1|2‘] 
‘1|2‘] 
‘1 |2 ,1 |2 ‘] 
Bit No.
Weight
Condition
4
16
Rubidium oscillator unlocked.1
3
8
Rubidium oscillator locked.1
2
4
Last measurement below low limit.
1
2
Last measurement above high limit.
Bit No.
Weight
Condition
2
4
Enable monitoring of low limit
1
2
Enable monitoring of high limit
Bit No.
Weight
Condition
11
2048
Computing statistics
10
1024
In limit
9
512
Using internal reference
8
256
Meas. stopped / Computing statistics (in compatibility mode)
6
64
Waiting for bus arming
5
32
Waiting for triggering and / or external arming
4
16
Measurement started
0
1
Calibrating
Bit No.
Weight
Condition
8
256
No measurement
6
64
Waiting for bus arming
5
32
Waiting for triggering and/or external arming
4
16
Measurement
Bit No.
Weight
Condition
14
16384
Unexpected parameter
11
2048
Out of limit
10
1024
Measurement timeout / Out of limit (in compatibility mode)
9
512
Overflow
8
256
Calibration error
6
64
Phase interpolation calibration off
5
32
Frequency interpolation calibration off
2
4
Time interpolation calibration off
Event Status Enable Register (1 = enable)
Event Status Enable Register (1 = enable)
Event Status Enable Register (1 = enable)
Bit
Weight
Enables
7
128
PON, Power-on occurred
6
64
URQ, User Request
5
32
CME, Command Error
4
16
EXE, Execution Error
3
8
DDE, Device Dependent Error
2
4
QYE, Query Error
1
2
RQC, Request Control (not used)
0
1
Operation Complete
Service Request Enable Register (1 = enable)
Service Request Enable Register (1 = enable)
Service Request Enable Register (1 = enable)
Bit
Weight
Enables
7
128
OPR, Operation Status
6
64
RQS, Request Service
5
32
ESB, Event Status Bit
4
16
MAV, Message Available
3
8
QUE, Questionable Data/Signal Status
2
4
EAV, Error Available
1
2
Not used
0
1
Device Status
Status Byte Register (1 = true)
Status Byte Register (1 = true)
Status Byte Register (1 = true)
Status Byte Register (1 = true)
Bit
Weight
Name
Condition
7
128
OPR
Enabled operation status has occurred.
6
64
MSS
Reason for requesting service
5
32
ESB
Enabled status event condition has occurred
4
16
MAV
An output message is ready
3
8
QUE
The quality of the output signal is questionable
2
4
EAV
Error available
1
2

Not used
0
1
DREG0
Enabled status device event conditions have occurred
<Integer> =
Error
0
No Error
1
RAM Failure
2
ROM Failure
4
Logic Failure
8
Display Failure
16

32
